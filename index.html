<html lang="en" class="dark-theme"><head><meta http-equiv="content-type" content="text/html;charset=UTF-8">


	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="author" content="ShozSheikh">
	<title>Java Interview Questions</title>
	<script>
		!function (theme, navWidth) {
			if (theme === 'dark') document.documentElement.classList.add('dark-theme')
			if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
		}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'),
			localStorage && localStorage.getItem('nav-width'))
	</script>
	<script>
		function closeOtherDetails(id) {
			const details = document.getElementsByTagName('details');
			for (let i = 0; i < details.length; i++) {
				if (details[i].id !== id) {
					details[i].removeAttribute('open');
				}
			}
		}
	</script>
	<style>
		@media screen and (min-width: 1025px) {
			.div-to-desk {
				display: none;
				/* Hide the div on screens smaller than 1025px (mobile) */
			}
		}

		@media screen and (max-width: 1025px) {
			.div-to-hide {
				display: none;
				/* Hide the div on screens smaller than 1025px (mobile) */
			}
		}
	</style>
</head>

<body>
	<nav class="navbar">
		<div class="navbar-brand">
			<a class="navbar-item" href="../../home.html"> <img width="40" height="25" src="../../scripts/images/nani1.png" alt="Home">
				<h5 href="../../home.html" class="div-to-hide berkshire-swash-regular">Shoz</h5>
			</a>
			<h4 class="div-to-desk berkshire-swash-regular" href="../../home.html">Sheikh</h4>
			<button class="navbar-burger" data-target="topbar-nav">
				<span></span> <span></span> <span></span>
			</button>
		</div>
		<div id="topbar-nav" class="navbar-menu">
			<div class="navbar-end">
				<div class="navbar-item" style="text-align: center;">
					<div class="nav-item is-hoverable" style="top: .2rem;"><a class="nav-link" href="../../home.html"><img height="25" width="25" src="../../scripts/images/home.png"></a></div>
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../java/introduction.html">Java_Paper-1</a>
					</div>
					<div class="toggle-content">


<p><b>Q1. What is Java?</b></p>
<p>Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a widely used language for developing
applications for web, mobile, and desktop platforms.</p>


<p><b>Q2. What are the features of Java?</b></p>
<p>Key features of Java include platform independence, object-orientation, security, robustness, simplicity, multithreading support, and garbage collection.</p>


<p><b>Q3. What is JVM and why is it important?</b></p>
<p>JVM stands for Java Virtual Machine, which is the part of the Java Run-time Environment that
executes Java byte code. It is important because it provides a platform-independent way of executing Java code.</p>


<p><b>Q4. What is the difference between JDK, JRE, and JVM?</b></p>
<p>JDK (Java Development Kit) is the full software development kit required to develop Java applications, JRE (Java Runtime Environment) is a subset of JDK that is required to run Java
applications, and JVM (Java Virtual Machine) is the component of JRE that executes Java bytecode.</p>


<p><b>Q5. What is the use of the public static void main(String[] args) method?</b></p>
<p>This method is the entry point for any Java application. It is the method called by the JVM to run the program.</p>


<p><b>Q6. Explain the concept of Object-Oriented Programming in Java.</b></p>
<p>Object-Oriented Programming (OOP) in Java is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (attributes) and code in the form of procedures (methods). Java uses OOP principles including inheritance, encapsulation, polymorphism, and abstraction.</p>


<p><b>Q7. What is inheritance in Java?</b></p>
<p>Inheritance is a fundamental OOP concept where one class can inherit fields and methods from another class. In Java, inheritance is achieved using the extends keyword.</p>


 
<p><b>Q8. What is polymorphism in Java?</b></p>
<p>Polymorphism in Java is the ability of an object to take on many forms. It is typically achieved through method overriding and method overloading.</p>


<p><b>Q9. Explain encapsulation with an example in Java.</b></p>
<p>Encapsulation in Java is the bundling of data (variables) and methods that operate on the data into a single unit, or class, and restricting access to some of the object's components. This is usually done by making fields private and providing public getter and setter methods. For example:


public class Employee { private String name;

public String getName() { return name;
}


public void setName(String newName) { this.name = newName;
}
}
</p>

<p><b>Q10. What is an interface in Java?</b></p>
<p>An interface in Java is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields. The methods in interfaces are abstract by default.</p>


<p><b>Q11. Explain the concept of an abstract class.</b></p>
<p>An abstract class in Java is a class that cannot be instantiated and may contain abstract methods, which do not have an implementation and must be implemented in subclasses.</p>


<p><b>Q12. What are constructors in Java?</b></p>




 
<p>Constructors in Java are special methods used to initialize objects. The constructor is called when an object of a class is created and has the same name as the class.
</p>

<p><b>Q13. What is method overloading?</b></p>
<p>Method overloading is a feature in Java that allows a class to have more than one method having the same name, if their parameter lists are different. It is a way of implementing compile-time
polymorphism.</p>


<p><b>Q14. What is method overriding?</b></p>
<p>Method overriding, in Java, is a feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes.
</p>

<p><b>Q15. What is a package in Java?</b></p>
<p>In Java, a package is a namespace that organizes a set of related classes and interfaces. Conceptually, packages are similar to different folders on your computer.
</p>

<p><b>Q16. Explain the final keyword in Java.</b></p>
<p>The final keyword in Java can be used to mark a variable as constant (not changeable), a method as not overrideable, or a class as not inheritable.

</p>
<p><b>Q17. What are Java Exceptions?</b></p>
<p>Exceptions in Java are events that disrupt the normal flow of the program. They are objects that wrap an error event that occurred within a method and are either caught or propagated further up the
calling chain.
</p>

<p><b>Q18. What is the difference between checked and unchecked exceptions?</b></p>
<p>Checked exceptions are exceptions that are checked at compile-time, meaning that the code must handle or declare them. Unchecked exceptions are checked at runtime, meaning they can be thrown without being caught or declared.

</p>
<p><b>Q19. What is the static keyword used for in Java?</b></p>
<p>The static keyword in Java is used to indicate that a particular field, method, or block of code belongs to the class, rather than instances of the class. Static members are shared among all instances of a class.
</p>



 
<p><b>Q20. What is a thread in Java?</b></p>
<p>A thread in Java is a lightweight subprocess, the smallest unit of processing. Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU.
</p>

<p><b>Q21. Explain the difference between == and .equals() in Java.</b></p>
<p>In Java, == operator is used to compare primitive data types and checks if two references point to the same object in memory. .equals() method is used to compare the contents of two objects.
</p>

<p><b>Q22. What is garbage collection in Java?</b></p>
<p>Garbage collection in Java is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that is run on the Java Virtual Machine (JVM).
When objects are no longer in use, the garbage collector attempts to reclaim memory on the JVM for reuse.
</p>

<p><b>Q23. What is the Collections Framework in Java?</b></p>
<p>The Collections Framework in Java is a unified architecture for representing and manipulating
collections. All collections frameworks contain interfaces, implementations, and algorithms to help Java programmers handle data efficiently.

</p>
<p><b>Q24. Explain synchronized keyword in Java.</b></p>
<p>The synchronized keyword in Java is used to control the access of multiple threads to any shared resource. It is used to prevent thread interference and consistency problems.
</p>

<p><b>Q25. What are generics in Java?</b></p>
<p>Generics are a feature that allows you to write and use parameterized types and methods in Java. Generics provide compile-time type safety that allows programmers to catch invalid types at compile time.

</p>
<p><b>Q26. What is the use of ‘this’ keyword in Java?</b></p>
<p>In Java, ‘this’ is a reference variable that refers to the current object. It can be used to refer current class instance variable, invoke current class method, pass as an argument in the method call, pass as argument in the constructor call, and return the current class instance.
</p>

<p><b>Q27. What is Enum in Java?</b></p>



 
<p>Enum in Java is a data type that consists of a fixed set of constants. Enums are used to create our own data types (Enumerated Data Types). It is used when we know all possible values at compile time, such as choices on a menu, rounding modes, command line flags, etc.
</p>

<p><b>Q28. What are threads?</b></p>
<p>In Java, threads are lightweight processes that allow a program to perform multiple tasks
simultaneously. Each thread runs a separate path of execution within the program. Java provides built-in support for threads through the Thread class and the Runnable interface.
By using threads, you can improve the performance of applications by handling tasks such as
background operations, parallel processing, and asynchronous tasks more efficiently. Threads share the same memory space, which makes communication between them easier but also requires
careful synchronization to avoid conflicts.

</p>
<p><b>Q29. What is multithreading?</b></p>
<p>Multithreading in Java is a process of executing multiple threads simultaneously. Thread is a
lightweight sub-process, a smallest unit of processing. It allows the concurrent execution of two or more parts of a program to maximize the utilization of CPU time.
</p>

<p><b>Q30. Explain volatile keyword in Java.</b></p>
<p>The volatile keyword in Java is used to indicate that a variable's value will be modified by different threads. Declaring a variable volatile ensures that its value is read from the main memory and not from the thread's cache memory.

</p>
							</div>
					
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="">Java_2</a>
					</div>
					
					<div class="toggle-content">                                


<b><p>JAVA ARCHITECTURE AND MEMORY MANAGEMENT</b></p>


<p><b>Can you tell me the difference between JVM, JRE, and JDK?</b>p></p>
<p>The JVM is the engine that runs Java bytecode and making Java platform-independent. The JRE contains the JVM and the standard libraries that Java programs need to run. The JDK is development kit for developers that contains everything in the JRE plus tools like compilers and debuggers to create Java applications.</p>
<p><b>What are the key components of JVM Architecture?</b></p>
<p>JVM has three components, the ClassLoader, the runtime data areas and the execution engine.
The Class Loader loads class files into the JVM. The Runtime Data Areas store data needed while the program runs, like memory for variables and code. The Execution Engine actually runs the instructions in the class files.</p>
<p><b>Can a Java application be run without installing the JRE?</b></p>
<p>We can't run a Java application without having the JRE (Java Runtime Environment) because it has the essential tools and libraries the application needs to work. But, there's a cool tool called jlink in newer Java versions that lets us bundle our Java application with its own little version of the JRE</p>
<p><b>Is it possible to have the JDK installed without having the JRE?</b></p>
<p>No, the JDK contains the JRE. It's not possible to have a JDK without a JRE, as the JRE contains essential components for running Java applications, which the JDK also uses for development.</p>

<p><b>What are Memory storages available with JVM?</b></p>
<p>JVM memory is divided into Heap Space, Stack Memory, Method Area (Metaspace in Java 8 and above), and Native Method Stacks.
Heap space in Java is where the program stores objects and data that it creates and shares.
Stack memory is used for keeping track of what happens inside each function call, including variable values.
The Method Area, or Metaspace in newer Java versions, stores information about the program's classes, like methods and constants.
</p>
<p><b>Which is faster to access between heap and stack, and why?</b></p>
The stack is faster to access because it stores method calls and local variables in a Last-In-First-Out (LIFO) structure. The heap, used for dynamic memory allocation (objects), is slower due to its more complex management.

<p><b>How does garbage collection work in Java?</b></p>
<p>Garbage collection in Java automatically frees memory by removing objects that are no longer used. It frees the memory by unused objects, making space for new objects.</p>

<p><b>Whats the role of finalized() method in garbage collection?</b></p>
<p>The finalize() method is called by the garbage collector on an object when it determines that there are no more references to the object. It's meant to give the object a chance to clean up resources before it's collected, such as closing file streams or releasing network connections.
</p>
	<p><b>Can you tell me what algorithm JVM uses for garbage collection?</b></p>
<p>JVM uses multiple garbage collection algorithms such as Mark-Sweep, Mark- Compact, and Generational Copying, depending on the collector chosen
</p>
<p><b>How can memory leaks occur in Java even we have automatic garbage collection?</b>p></b>
<p>Memory leaks in Java occur when objects are no longer needed but still referenced from other reachable objects, and hence preventing the garbage collector from reclaiming their memory.
</p>

<b><p>Java Fundamentals</b></p>

<p><b>Is java 100% object oriented programming language ?</b></p>
No, Java is not considered 100% object-oriented because it uses primitive types (like int, char, etc.) that are not objects. In a fully object-oriented language, everything is treated as an object.
<p><b>What are the advantages of Java being partially object-oriented?</b></p>
1.	Using simple, non-object types like integers and booleans helps Java run faster and use less memory.
2.	The mix of features allows Java to work well with other technologies and systems, which might not be fully object-oriented.
<p><b>What is the use of object-oriented programming languages in the enterprise projects?</b></p>



 
Object-oriented programming (OOP) is used in big projects to make coding easier to handle. It helps organize code better, makes it easier to update and scale, and lets programmers reuse code, saving time and effort.

<p><b>Explain public static void main(string args[])?</b></p>
In Java, public static void main(String[] args) is the entry point of any standalone Java application.

public makes this method accessible from anywhere, static means I don't need
to create an object to call this method, void means it doesn't return any value, and main is the name of this method.

The String[] args part is an array that holds any command-line arguments passed to the program. So, when I run a Java program, this is the first method that gets called
<p><b>What will happen if we declare don’t declare the main as static?</b></p>
If I don't declare the main method as static in a Java program, the JVM won't be able to launch the application.
As aresult, the program will compile, but it will fail to run, giving an error like "Main method is not static in class myClass, please define the main method as: public static void main(String[] args)."
<p><b>Can we override the main method?</b></p>
No, we cannot override main method of java because a static method cannot be overridden.
The static method in java is associated with class whereas the non-static method is
associated with an object. Static belongs to the class area, static methods don’t need an
object to be called.
<p><b>Can we oveload the main method?</b></p>
Yes, We can overload the main method in java by just changing its argument
<p><b>Can JVM execute our overloaded main method ?</b></p>
No, JVM only calls the original main method, it will never call our overloaded main method.


<p><b>Whats the difference between primitive data types and non primitive data types ?</b></p>
 Primitive data types in Java are the basic types of data predefined by the language and named by a keyword. They have a fixed size and are not objects. Examples include int, double, char, and boolean.
Non-primitive data types, on the other hand, are objects and classes that are not defined by Java itself but rather by the programmer or the Java API. They can be used to call methods

 
to perform certain operations, and their size is not fixed. Examples include String, arrays, and any class instances.
<p><b>Can primitive data types be NULL ?</b></p>
No, primitive data types in Java cannot be null. They have default values (e.g., 0 for int, false for boolean, 0.0 for double) and must always have a value.
<p><b>Can we declare pointer in java ?</b></p>
No, Java doesn’t provide the support of Pointer. As Java needed to be more secure
because which feature of the pointer is not provided in Java.
<p><b>What is the difference between == and .equals() in Java?</b></p>
== compares object references (whether two references point to the same object), while equals() compares object content (whether two objects are logically equal).

<p><b>What are wrapper classes?</b></p>
In Java, a wrapper class is an object that encapsulates a primitive data type. It allows primitives to be treated as objects. Each primitive data type has a corresponding wrapper class (e.g., Integer for int, Double for double).
<p><b>Why do we need wrapper classes?</b></p>
1.	Wrapper classes are final and immutable
2.	Provides methods like valueOf(), parseInt(), etc.
3.	It provides the feature of autoboxing and unboxing.
<p><b>Why we use wrapper class in collections</b></p>
Because Java collections, such as ArrayList, HashMap, and others in the Java Collections Framework, can only hold objects and not primitive types. Wrapper classes allow primitive values to be treated as objects, enabling them to be stored and managed within these collections.


<p><b>Can you explain the difference between unboxing and autoboxing in Java?</b></p>
Autoboxing automatically converts a primitive type (like int) to its corresponding wrapper class (Integer). Unboxing does the reverse, converting an Integer back to an int.

<p><b>Can you provide an example where autoboxing could lead to unexpected behavior?</b></p>
When comparing two Integer instances using ==, autoboxing might lead to false results because it compares object references, not values, for integers outside the cache range of -128 to 127.
<p><b>Is there a scenario where autoboxing and unboxing could cause a NullPointerException?</b></p>


 
A NullPointerException can occur if you unbox a null object; for example, assigning null to an Integer and then using it in a context where an int is expected.

<p><b>Can you explain the role of each try, catch, and finally block in exception handling?</b></p>
try block conatins code that might throw exceptions. catch handles those exceptions. finally executes code after try/catch, regardless of an exception, typically for cleanup.

<p><b>What happens if a return statement is executed inside the try or catch block? Does the finally block still execute?</b></p>
The finally block executes even if a return statement is used in the try or catch block, ensuring cleanup runs.

<p><b>Is it possible to execute a program without a catch block? If so, how would you use try and finally together?</b></p>
Yes, we can use try with finally without a catch block to ensure cleanup occurs even if we allow the exception to propagate up.
<p><b>How does exception handling with try-catch-finally affect the performance of a Java application?</b></p>
Using try-catch-finally can affect performance slightly due to overhead of managing exceptions but is generally minimal unless exceptions are thrown frequently.

<p><b>Can you tell me a condition where the finally block will not be executed?</b></p>
The finally block will not execute if the JVM exits via System.exit() during try or catch execution.
<p><b>Can we write multiple finally blocks in Java?</b></p>
No, each try can only have one finally block. Multiple finally blocks are not allowed within a single try-catch-finally structure.
<p><b>What is the exception and the differences between checked and unchecked exceptions?</b></p>
Exception is the unwanted even that occurs during the execution of program and disrupts the flow.
Checked exceptions must be declared or handled (IOException); unchecked do not need to be declared or caught (NullPointerException).
<p><b>How would you handle multiple exceptions in a single catch block</b></p>
Use a single catch block for multiple exceptions by separating them with a pipe (|), e.g., catch (IOException | SQLException e), to handle both exceptions with the same logic.
<p><b>What is the difference between a Throwable and an Exception in Java?</b></p>
 Throwable is the superclass for all errors and exceptions. Exception is a subclass of Throwable representing recoverable conditions, while Error (another subclass) represents serious issues the application should not attempt to recover from.

 
<p><b>Discuss the difference between finalize() and finally. Under what circumstances might finalize() not get called in a Java application?</b></p>
finalize() is called by the garbage collector before an object is destroyed, while finally is used in a try-catch block to execute code regardless of exceptions. finalize() may not get called if the garbage collector doesn't run or the JVM shuts down.


<p><b>What is string pool?</b></p>
A Java String Pool is a place in heap memory where all the strings defined in the program are stored. Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.

<p><b>Are there any scenarios where using the string pool might not be beneficial?</b></p>
 It will not be beneficial when there are a lot of uique string because it will be complex situate to check each string.

<p><b>Can you please tell me about String and string buffer?</b></p>
'String; in Java is immutable, meaning once created, its value cannot be changed. 'StringBuffer' is mutable, allowing for modification of its contents and is thread-safe, making it suitable for use in multithreaded environments where strings need to be altered.

<p><b>How does StringBuilder differ from StringBuffer, and when should each be used? </b></p>
StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.

<p><b>Give a scenario where StringBuffer is better than the String?</b></p>
A scenario where StringBuffer is more appropriate than String is in a multi-threaded server application where multiple threads modify a shared string, such as constructing a complex log entry concurrently from different threads.
<p><b>What is the difference between a String literal and a String object?</b></p>
A String literal is stored in the String pool for reusability. A String object, created using new String(), is stored in the heap, even if it has the same value as a literal.

<p><b>Why is String immutable?</b></p>
String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.

<p><b>What are the packages in Java?</b></p>
In Java, packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code, allowing related classes to be grouped together logically.


 
<p><b>Why packages are used?</b></p>
1.	They help in organizing code
2.	Packages prevent naming conflicts by providing a unique namespace
3.	Packages support modularity by allowing developers to separate the program
4.	Organizing classes into packages makes it easier to locate related classes


Object Oriented Programming Concepts


<p><b>What are access modifies in java?</b></p>
ava uses public, protected, default (no modifier), and private to control access to classes, methods, and fields, ensuring appropriate visibility and encapsulation.
<p><b>Can you provide examples of when to use each type of access modifier?</b></p>
1.	Public: Used when members should be accessible from any other class.
2.	Protected: Ideal for members that should be accessible to subclasses and classes within the same package.
3.	Default: Use when members should be accessible only within the same package.
4.	Private: Best for members intended only for use within their own class.

<p><b>Why do we use getters setter when we can make fields publick and setting getting directly?</b></p>
Using getters and setters instead of public variables allows us to control how values are set and accessed, add validation, and keep the ability to change how data is stored without affecting other parts of your program.
<p><b>Can a top-level class be private or protected in Java?</b></p>
No, a top-level class cannot be private or protected because it restricts access, making it unusable from any other classes, contrary to the purpose of a top-level class.


<p><b>Explain the concepts of classes and objects in Java.</b></p>
Classes are blueprints for objects in Java, defining the state and behavior that the objects of the class can have. Objects are instances of classes, representing entities with states and behaviors defined by their class.
<p><b>What are the ways to create an object?</b></p>
1.	Using the new Keyword, example: MyClass object = new MyClass();


 
2.	Using Class Factory Methods, example: Calendar calendar = Calendar.getInstance();
3.	Using the clone()
<p><b>Can a class in Java be without any methods or fields?</b></p>
Yes, a class in Java can be declared without any methods or fields. Such a class can still be used to create objects, although these objects would have no specific behavior or state
<p><b>What are the methods available in the Object class, and how are they used?</b></p>
The key methods are equals(), hashCode(), toString(), clone(), finalize(), wait(), notify(), and notifyAll(). These provide basic operations like equality checks, memory management, and thread coordination.

<p><b>What are anonymous classes and their advantages?</b></p>
Anonymous classes in Java are classes without a name, defined and instantiated in one place. They are useful when you need to create a subclass or implement an interface for a one-time use. The advantages include reduced boilerplate code, encapsulation of specific functionality, and the ability to override methods on the fly. This results in more compact and localized code, particularly in scenarios like event handling or passing behavior as an argument.

<p><b>What is Singleton Class?</b></p>
A singleton class in Java is a special class that can have only one instance (or object) at any time. It's like having only one key of the room. This is useful when we want to make sure there's just one shared resource, like a configuration setting or a connection to a database.

<p><b>How can we create this singleton class?</b></p>
In order to make singleton class, first we have a to make a constructor as private, next we have to create a private static instance of the class and finally we have to provide static method instance so that’s how we can create the singleton class
<p><b>Are these threads safe?</b></p>
Singleton classes are not thread-safe by default. If multiple threads try to create an instance at the same time, it could result in multiple instances. To prevent this, we can synchronize the method that creates the instance or use a static initializer


<p><b>What is a constructor in Java?</b></p>
A constructor in Java is a special method used to initialize new objects. It has the same name as the class and may take arguments to set initial values for the object's attributes.

<p><b>Can we use a private constructor?</b></p>
Yes, we can use private constructors in Java. They are mostly used in classes that provide static methods or contain only static fields. A common use is in the Singleton design pattern, where the goal is to limit the class to only one object.

 
<p><b>Can constructor be overloaded?</b></p>
Yes, you can have multiple constructors in a Java class, each with a different set of parameters. This lets you create objects in various ways depending on what information you have at the time.

<p><b>What is immutability mean in Java?</b></p>
Immutability in Java means that once an object's state is created, it cannot be changed.

<p><b>Why immutable objects are useful for concorrent programming?</b></p>
These are useful in concurrent programming because they can be shared between threads without needing synchronization.

<p><b>What are immutable classes?</b></p>
Immutable classes in Java are classes whose objects cannot be modified after they are created. This means all their fields are final and set only once, typically through the constructor.
<p><b>How can we create immutable class?</b></p>
1.	Declare the class as final so it can’t be extended.
2.	Make all of the fields final and private so that direct access is not allowed.
3.	Don’t provide setter methods for variables
4.	Initialize all fields using a constructor method


<p><b>What does Java's inheritance mean?</b></p>
Inheritance in Java means a class can use the features of another class. This helps to reuse code and make things simpler.
<p><b>Can a class extends on its own</b></p>
No, a class in Java cannot extend itself. If it tries, it will cause an error
<p><b>Why multiple inheritance is not possible in java?</b></p>
Java avoids using multiple inheritance because it can make things complicated, such as when two parent classes have methods that conflict.

<p><b>What is the difference between inheritance and composition?</b></p>
Inheritance is when one class gets its features from another class. Composition is when a class is made using parts from other classes, which can be more flexible.
<p><b>Discuss the principle of "composition over inheritance".</b></p>
	Provide an example where this principle should be applied in Java application design.
"Composition over inheritance" means using objects within other objects
(composition) instead of inheriting from a parent class. It’s applied when classes

 
have a "has-a" relationship. For example, a Car class can have an Engine class as a field rather than inheriting from an Engine.
<p><b>What is the difference between association, aggregation, and composition in Java?</b></p>
 Association is a general relationship between two classes. Aggregation is a weak association (has-a) where the child can exist independently of the parent.
Composition is a strong association where the child cannot exist without the parent.

<p><b>Explain the IS-A (inheritance) and Has-A (composition) relationships in Java.</b></p>
IS-A refers to inheritance, where a subclass is a type of the superclass. Has-A refers to composition, where a class contains references to other classes as fields.
<p><b>What does mean by polymorphism in Java?</b></p>
Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.

<p><b>How does method overloading relate to polymorphism?</b></p>
Method overloading is using the same method name with different inputs in the same class. It's a simple way to use polymorphism when you're writing your code.
<p><b>What is dynamic method dispatch in Java?</b></p>
Dynamic method dispatch is a way Java decides which method to use at runtime when methods are overridden in subclasses. It ensures the correct method is used based on the type of object.

<p><b>Can constructors be polymorphic?</b></p>
No, constructors cannot be polymorphic. We can have many constructors in a class with different inputs, but they don’t behave differently based on the object type like methods do.

<p><b>What does mean by abstraction in java?</b></p>
Abstraction in Java means focusing on what needs to be done, not how to do it. You create a kind of blueprint that tells other parts of the program what actions they can perform without explaining the details.

<p><b>Can you provide examples of where abstraction is effectively used in Java libraries?</b></p>
 Java uses abstraction in its collection tools. For example, when you use a List, you don't need to know how it stores data, whether as an ArrayList or a LinkedList.
<p><b>What happens if a class includes an abstract method?</b></p>
A class with an abstract method must itself be abstract. We can't create objects directly from an abstract class; it's meant to be a blueprint for other classes.
<p><b>How does abstraction help in achieving loose coupling in software applications?</b></p>


 
Abstraction lets us hide complex details and only show what's necessary. This makes it easier to change parts of your program without affecting others, keeping different parts independent and easier to manage.

<p><b>What is interface in Java?</b></p>
interface is like a blueprint for a class. It defines a set of methods that the class must implement, without specifying how these methods should work

<p><b>What is the difference between an interface and an abstract class in Java?</b></p>
 abstract class achieves partial abstraction (0 to 100%) whereas interface achieves fully abstraction. Abstract class can have abstract and non-abstract methods
whereas Interface can have only abstract methods. (Since Java 8, it can have default and static methods also.)
<p><b>Can you provide examples of when to use an interface versus when to extend a class?</b></p>
Use an interface when we want to list the methods a class should have, without detailing how they work. Use class extension when we want a new class to inherit features and behaviors from an existing class and possibly modify them.
<p><b>How do you use multiple inheritance in Java using interfaces?</b></p>
In Java, we can't inherit features from multiple classes directly, but we can use interfaces for a similar effect. A class can follow the guidelines of many interfaces at once, which lets it combine many sets of capabilities.
<p><b>Can an interface in Java contain static methods, and if so, how can they be used?</b></p>
 Yes, interfaces in Java can have static methods, which you can use without creating an instance of the class.

<p><b>When would you use an interface, and when would you use an abstract class?</b></p>
 Use an interface when you need multiple classes to share a contract without implementation. Use an abstract class when you need shared behavior (method implementations) along with method declarations.
<p><b>Explain the difference between Comparable and Comparator interfaces. When would you use one over the other?</b></p>
Comparable is used for natural ordering and is implemented by the class itself, while Comparator is used for custom ordering and can be implemented externally. Use Comparable when objects have a single logical ordering; use Comparator when you need multiple ways to order objects.
<p><b>What is a static method in an Interface, and how is it different from a default method in an interface?</b></p>
A static method in an interface belongs to the interface itself and cannot be overridden. A default method provides a default implementation for classes that implement the interface, and it can be overridden.
 
<p><b>What is the diamond problem in Java and how does Java address it?</b></p>
The diamond problem occurs in multiple inheritance where a class inherits from two classes with a common ancestor. Java resolves this by not allowing multiple inheritance with classes, but interfaces can use default methods to avoid this issue.
<p><b>How does the concept of default methods in interfaces help resolve the diamond problem?</b></p>
Default methods allow interfaces to provide method implementations, and in case of conflicts (multiple interfaces with the same default method), the implementing class must override the method, resolving ambiguity.


<p><b>What does mean by encapsulation in java?</b></p>
Encapsulation in Java is like putting important information into a safe. We store data and the methods inside a class, and we control who can access or change the data by using specific methods.
<p><b>How Encapsulation Enhances Software Security and Integrity:</b></p>
Encapsulation keeps important data hidden and safe. It only lets certain parts of our program use this data, which helps prevent mistakes and keeps the data secure from unwanted changes.

<p><b>What is the concept of Serialization in Java?</b></p>
Serialization is the process of converting an object into a byte stream for storage or transmission. It allows objects to be saved and restored later or transferred over a network.
<p><b>What is the purpose of the serialVersionUID in Java serialization?</b></p>
The serialVersionUID is a unique identifier for Serializable classes. It ensures that the serialized and deserialized objects are compatible by checking version consistency. If the serialVersionUID of the class doesn’t match during deserialization, an InvalidClassException is thrown, preventing incompatible class versions from being used.
<p><b>What happens if the serialVersionUID of a class changes during deserialization?</b></p>
 If the serialVersionUID changes between serialization and deserialization, the JVM considers the class as incompatible with the serialized object. This results in an InvalidClassException, as the runtime expects the version of the serialized class to match with the version defined in the deserialized class.

<p><b>How can you prevent certain fields from being serialized in Java</b></p>
You can prevent specific fields from being serialized by marking them with the transient keyword. When a field is declared as transient, it is excluded from the serialization process, meaning its value will not be saved when the object is serialized.
<p><b>Can a class be serialized if one of its member fields is not serializable?</b></p>

 
A class can still be serialized even if one of its member fields is not serializable. However, you must mark the non-serializable field as transient. If the field is not transient and is not serializable, attempting to serialize the object will result in a NotSerializableException.
<p><b>What is the difference between writeObject() and readObject() methods in Java serialization?</b></p>
The writeObject() and readObject() methods allow customization of the serialization and deserialization processes. writeObject() is used to customize how an object is serialized, while readObject() customizes how it is deserialized. These methods can be overridden to handle complex scenarios, such as serializing transient fields or managing class versioning.

<p><b>Is it possible to serialize static fields in Java? Why or why not?</b></p>
No, static fields are not serialized in Java because they belong to the class, not to individual instances. Serialization is intended to capture the state of an object, and static fields are part of the class's state, not the object's state.
<p><b>How do you serialize an object with circular references in Java?</b></p>
Java handles circular references during serialization by keeping track of references that have already been serialized. When the same object reference appears again, Java writes a reference to the already serialized object rather than serializing it again. This prevents infinite recursion and maintains the object graph structure.


<p><b>What is method overloading in Java?</b></p>
Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.
<p><b>How does the Java compiler determine which overloaded method to call? When we call an overloaded method, the Java compiler looks at the number and type of arguments you've provided and picks the method that matches these arguments best.
<p><b>Is it possible to overload methods that differ only by their return type in Java? In Java, we cannot overload methods just by changing their return type. The methods must differ by their parameters for overloading to be valid.

<p><b>What are the rules for method overloading in Java?</b></p>
The parameters must differ in how many there are, what type they are, or the order they are in.

<p><b>What is method overriding in Java?



 
To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.
<p><b>What are the rules and conditions for method overriding in Java?</b></p>
In Java, method overriding occurs when a subclass has a method with the same name, return type, and parameters as one in its parent class. The method in the subclass replaces the one in the parent class when called.

<p><b>How does the @Override annotation influence method overriding?</b></p>
The @Override annotation tells the compiler that the method is supposed to replace one from its superclass. It's useful because it helps find mistakes if the method does not actually override an existing method from the parent class.

<p><b>What happens if a superclass method is overridden by more than one subclass in Java?</b></p>
If different subclasses override the same method from a superclass, each subclass will have its own version of that method.
<p><b>What is 'this' and 'super' keyword in java?</b></p>
'this' is used to refer current class's instance as well as static members. 'super' keyword is used to access methods of the parent class.

<p><b>Can 'this' keyword be assigned a new value in Java?</b></p>
No, this keyword cannot be assigned a new value in Java. It is a read-only reference that always points to the current object.
<p><b>What happens if you attempt to use the "super" keyword in a class that doesn't have a superclass?</b></p>
If we attempt to use the "super" keyword in a class that doesn't have a superclass, a compilation error occurs. The "super" keyword is only applicable within subclasses to refer to members of the superclass.
<p><b>Can the this or super keyword be used in a static method?</b></p>
No, the this and super keyword cannot be used in static methods. Static methods belong to the class, not instances, and super refers to the superclass's object context, which does not exist in a static context.
<p><b>How does 'super' play a role in polymorphism ?</b></p>
In Java, the super keyword lets a subclass use methods from its parent class, helping it behave in different ways and that is nothing but a polymorphic behavior


<p><b>What is the static keyword in Java?</b></p>
The static keyword in Java is used to indicate that a particular member (variable or method) belongs to the class, rather than any instance of the class. This means that the static member can be accessed without creating an instance of the class.

 
<p><b>Can a static block throw an exception?</b></p>
Yes, a static block can throw an exception, but if it does, the exception must be handled within the block itself or declared using a throws clause in the class.
<p><b>Can we override static methods in Java?</b></p>
No, static methods cannot be overridden in Java because method overriding is based on dynamic binding at runtime and static methods are bound at compile time.

<p><b>Is it possible to access non-static members from within a static method?</b></p>
No, it's not possible to access non-static members (instance variables or methods) directly from within a static method. This is because static methods belong to the class itself, not to any specific instance. To access non-static members, you need to create an instance of the class and use that object to reference the non-static members.
<p><b>What is static block?</b></p>
To initialize static variables, the statements inside static block are executed only once, when the class is loaded in the memory.

<p><b>Can we print something on console without main method in java?</b></p>
Prior to Java 8, yes, we can print something without main method buts its not possible from java 8 onwards

<p><b>What is final keyword in java?</b></p>
the 'final' keyword is used to declare constants, making variables unchangeable once assigned, or to prevent method overriding or class inheritance
<p><b>What are some common use cases for using final variables in Java programming?</b></p>
 Common use cases for using final variables in Java programming include defining constants, parameters passed to methods, and local variables in lambdas or anonymous inner classes.
<p><b>How does the "final" keyword contribute to immutability and thread safety in Java?</b></p>
The "final" keyword contributes to immutability and thread safety in Java by ensuring that the value of a variable cannot be changed once assigned, preventing unintended modifications and potential concurrency issues.

<p><b>Can you describe any performance considerations related to using final?</b></p>
The final keyword improves the performance by reducing call overhead?

<p><b>What is functional interfaces?</b></p>



 
Functional interfaces in Java are interfaces with just one abstract method. They are used to create lambda expressions and instances of these interfaces can be created with lambdas, method references, or constructor references.
<p><b>Can functional interface extend another interface?</b></p>
No, as functional interface allows to have only single abstract method. However functional interface can inherit another interface if it contains only static and default methods in it

<p><b>Advantages of using a functional interface.</b></p>
Functional interfaces, which contain only one abstract method, are key to enabling functional programming in Java. They offer concise and readable code through lambda expressions and method references, improving code simplicity. Functional interfaces allow easy parallel processing, better abstraction, and reusability, especially in scenarios like streams and event handling, promoting a cleaner and more expressive programming style.


</b></p>Java 8 Basics</b></p>
<p><b>Can you tell me some new features that were introduced in Java 8?</b></p>
Lambda Expressions, Stream API, Method References , Default Methods , Optional Class, New Date-Time API are the new features that were introduced in java 8

<p><b>Why optional class, lambda expressions and stream API were introduced in java 8?</b></p>
 Optional class was introduced in Java 8 as a way to address the problem of null references
Lambda expressions were introduced in Java 8 to make it easier to write code for interfaces that have only one method, using a simpler and more direct style.
The Stream API was introduced in Java 8 to help developers process collections of data in a more straightforward and efficient way, especially for bulk operations like filtering or sorting.
<p><b>Difference between filter and map function of stream API?</b></p>
filter() eliminates elements of collection where the condition is not satisfied whereas map() is used to perform operation on all elements hence, it returns all elements of collection

<p><b>Can you tell me some new features that were introduced in Java 11?</b></p>
HTTP Client, Epsilon Garbage Collector, Z Garbage Collector, Local-Variable Syntax for Lambda Parameters are some of the new features and along with these new features, isBlank(), strip(), stripLeading(), stripTrailing(), and repeat() were also introduced for strings
<p><b>Can you tell me some new features that were introduced in Java 17?</b></p>
Sealed Classes, Pattern Matching for switch, Foreign Function and Memory API are some of the examples
 
<p><b>Can you tell me some new features that were introduced in Java 21?</b></p>
Virtual Threads, Structured Concurrency, Scoped Values, Sequenced Collections, Record Pattern are some of the examples
<p><b>Which is faster, traditional for loop or Streams?
Traditional for loops are generally faster due to less overhead, but Streams provide better readability and are optimized for parallel processing in large datasets.

<p><b>In which scenarios would you prefer traditional for loops and streams?</b></p>
Use traditional loops for simple, small datasets requiring maximum performance. Use Streams for more complex data transformations or when working with large datasets where readability, maintainability, and potential parallelism are prioritized.

<p><b>Explain intermediate and terminal operations in streams.</b></p>
Intermediate operations (e.g., filter(), map()) return another stream and are lazy (executed only when a terminal operation is called). Terminal operations (e.g., forEach(), collect()) trigger the actual processing of the stream and produce a result or side effect.
<p><b>Differences in Interface from Java 7 to Java 8.
In Java 7, interfaces could only have abstract methods. Java 8 introduced default and static methods, allowing interfaces to have method implementations.
<p><b>Use of String.join(….) in Java 8?
String.join() concatenates a sequence of strings with a specified delimiter, simplifying string joining operations.


<p><b>Collection Framework</b></p>
<p><b>What is collection framework in java?</b></p>
The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.
<p><b>What are the main interfaces of the Java Collection Framework?</b></p>
The main parts of the Java Collection Framework are interfaces like Collection, List, Set, Queue, and Map. Each one helps manage data in different ways.
<p><b>Can you explain how Iterator works within the Java Collection Framework? An Iterator is a tool in the Collection Framework that lets you go through a collection's elements one by one.
<p><b>What are some common methods available in all Collection types?</b></p>
Some common methods all collection types have are add, remove, clear, size, and isEmpty. These methods let us add and remove items, check the size, and see if the collection is empty.
 
<p><b>How does Java Collection Framework handle concurrency?</b></p>
The Collection Framework deals with multiple threads using special collection classes like ConcurrentHashMap and CopyOnWriteArrayList, which let different parts of our program modify the collection at the same time safely.
<p><b>How do you choose the right collection type for a specific problem?</b></p>
To pick the right collection type, think about what we need: List if you want an ordered collection that can include duplicates, Set if you need unique elements, Queue for processing elements in order, and Map for storing pairs of keys and values.

<p><b>What enhancements were made to the Java Collection Framework in Java 8?</b></p>
Java 8 made improvements to the Collection Framework by adding Streams, which make it easier to handle collections in bulk, and lambda expressions, which simplify writing code for operations on collections.
<p><b>What is the difference between Iterator and listIterator?</b></p>
Iterator allows forward traversal of a collection, while ListIterator extends Iterator functionality to allow bidirectional traversal of lists and also supports element modification.

<p><b>Name of algorithm used by Arrays.sort(..) and Collections.sort(..)?</b></p>
Arrays.sort() uses a Dual-Pivot Quicksort algorithm for primitive types and TimSort for object arrays. Collections.sort() uses TimSort, a hybrid sorting algorithm combining merge sort and insertion sort.
<p><b>How do you store elements in a set to preserve insertion order?</b></p>
Use a LinkedHashSet, which preserves the insertion order of elements.

<p><b>How do you store elements in a way that they are sorted?</b></p></b></p>
Use a TreeSet or a TreeMap, which automatically sorts elements based on their natural ordering or a specified comparator.

<p><b>Whats the use case of arrayList, linkedList and Hashset?</b></p>
We use arrayList where we need efficient random access to elements via indices, like retrieving elements frequently from a list without altering it.

We use LinkedList where you frequently add and remove elements from the beginning or middle of the list, such as implementing queues or stacks.

We use HashSet where we need to ensure that there are no duplicates and we require fast lookups, additions, and deletions. It is ideal for scenarios like checking membership existence, such as in a set of unique items or keys.
<p><b>How does a HashSet ensure that there are no duplicates?</b></p>

 
A HashSet in Java uses a HashMap under the hood. Each element you add is treated as a key in this HashMap. Since keys in a HashMap are unique, HashSet automatically prevents any duplicate entries.
<p><b>Can you describe how hashCode() and equals() work together in a collection</b></p>
 hashCode() determines which bucket an object goes into, while equals() checks equality between objects in the same bucket to handle collisions, ensuring that each key is unique.

<p><b>Why is it important to override the hashCode method when you override equals?</b></p>
What would be the consequence if we don’t?
Overriding hashCode() is crucial because hash-based collections like HashMap and HashSet use the hashcode to locate objects. Without consistent hashCode() and equals(), objects may not be found or stored correctly.
<p><b>Can you give an example where a TreeSet is more appropriate than HashSet?
 A TreeSet is more appropriate than a HashSet when you need to maintain the elements in a sorted order. For example, if we are managing a list of customer names that must be displayed alphabetically, using a TreeSet would be ideal.
<p><b>What is the internal implementation of ArrayList and LinkedList?</b></p>
ArrayList is backed by a dynamic array, which provides O(1) access time but requires resizing. LinkedList is implemented as a doubly-linked list, providing O(1) insertion and deletion at both ends but O(n) access time.


<p><b>Can you explain internal working of HashMap in Java?</b></p>
A HashMap in Java stores key-value pairs in an array where each element is a bucket. It uses a hash function to determine which bucket a key should go into for efficient data retrieval. If two keys end up in the same bucket, a Collison happened then the HashMap manages these collisions by maintaining a linked list or a balanced tree depend upon the java version in each bucket.
<p><b>What happens when two keys have the same hash code? How would you handle this scenario?</b></p>
When two different Java objects have the same hashcode, it's called a hash collision. In this case, Java handles it by storing both objects in the same bucket in a hash- based collection, like a HashMap. It then compares the objects using the equals() method to differentiate them.

<p><b>How does a HashMap handle collisions in Java?</b></p>
In Java, when a HashMap encounters a collision (two keys with the same hashcode), it stores both entries in the same bucket. Prior to Java 8, it linked them in a simple list structure. In Java 8, if the number of entries in a bucket grows large, the list is converted to a balanced tree for faster lookups.



 
<p><b>Can you please tell me what changes were done for the HashMap in Java 8 because before java 8 hashMap behaved differently ?</b></p>
Before Java 8, HashMap dealt with collisions by using a simple linked list. Starting from Java 8, when too many items end up in the same bucket, the list turns into a balanced tree, which helps speed up searching.
<p><b>Can we include class as a key in hashmap?</b></p>
No, as functional interface allows to have only single abstract method. However functional interface can inherit another interface if it contains only static and default methods in it

<p><b>Can you please explain ConcurrentHashMap</b></p>
ConcurrentHashMap is a version of HashMap that's safe to use by many threads at once without needing to lock the entire map. It divides the map into parts that can be locked separately, allowing better performance.
<p><b>How does it(ConcurrentHashMap ) improve performance in a multi-threaded environment?</b></p>
ConcurrentHashMap boosts performance in multi-threaded settings by letting different threads access and modify different parts of the map simultaneously, reducing waiting times and improving efficiency.

<p><b>What is time complexities insertions, deletion and retrieval of hashSet and HashMap?</b></p>
1.	Insertion:
2.	Average: O(1)
3.	Worst case: O(n) when rehashing occurs
4.	Deletion:
5.	Average: O(1)
6.	Worst case: O(n) when rehashing occurs
7.	Retrieval:
8.	Average: O(1)
9.	Worst case: O(n) when rehashing occurs (due to hash collisions) NOTE: HashSet and HashMap are not internally sorted
<p><b>What is time complexities insertions, deletion and retrieval of TreeSet and TreeMap?</b></p>
O(log n) for operations like insertions, deletion and retrieval NOTE: HashSet and HashMap are not internally sorted
<p><b>What techniques did hashMap, treeMap, hashSet and TreeSet uses internally for performing operations?</b></p>
HashMap uses an array of nodes, where each node is a linked list or Tree depend upon the collisions and java versions ( From Java 8 onwards, if there is high hash collisons then linkedList gets converted to Balanced Tree).

 
TreeMap uses a Red-Black tree, which is a type of self-balancing binary search tree. Each node in the Red-Black tree stores a key-value pair.
HashSet internally uses a HashMap whereas TreeSet internally uses TreeMap


<p><b>Design Patterns and Principles Basics</b></p>

<p><b>What is a design pattern in Java and why do we use this?</b></p>
Design patterns are proven solutions for common software design problems. They provide standardized approaches to organize code in a way that is maintainable, scalable, and understandable.

<p><b>Can you list and explain a few common design patterns used in Java programming?</b></p>
Common design patterns in Java:
1.	Singleton: Ensures a class has only one instance, with a global access point.
2.	Observer: Allows objects to notify others about changes in their state.
3.	Factory Method: Delegates the creation of objects to subclasses, promoting flexibility.
<p><b>How can design patterns affect the performance of a Java application?</b></p>
Design patterns can impact performance by adding complexity, but they improve system architecture and maintainability. The long-term benefits often outweigh the initial performance cost.
<p><b>Which design pattern would you use to manage database connections efficiently in a Java application?</b></p></b></p>
The Singleton pattern is commonly used to manage database connections, ensuring a single shared connection instance is reused efficiently.
<p><b>How do you choose the appropriate design pattern for a particular problem in Java?</b></p>
Understand the problem fully, identify similar problems solved by design patterns, and consider the implications of each pattern on the application’s design and performance.

<p><b>Difference between HashMap and TreeMap.</b></p>
HashMap stores key-value pairs without ordering, while TreeMap sorts the entries by keys. TreeMap has O(log n) operations due to its tree structure, whereas HashMap has O(1) operations under ideal conditions.
<p><b>In what scenarios would you prefer to use a TreeMap over a HashMap?</b></p>
Use a TreeMap when you need to maintain a sorted order of keys, such as when iterating over sorted data. A HashMap is preferable for fast lookups without concern for ordering.
<p><b>Can we add objects as a key in TreeMap?</b></p>
 
Yes, objects can be used as keys in a TreeMap if they implement the Comparable interface or a Comparator is provided for sorting the keys.

<p><b>What are SOLID Principles?</b></p>

'S' stands for Single Responsibility Principle: It means a class should only have one reason to change, meaning it should handle just one part of the functionality.
For Example: A class VehicleRegistration should only handle vehicle registration details. If it also takes care of vehicle insurance, then it will violates this.
'O' stands for Open/Closed Principle: It means Classes should be open for extension but closed for modification.
For Example: We have a VehicleService class that provides maintenance services. Later, we need to add a new service type for electric vehicles and if without modifying VehicleService, we are able to extend it from a subclass ElectricVehicleService then it follows this priciple. 'L' stands for Liskov Substitution Principle: It means Objects of a superclass should be
replaceable with objects of its subclasses without affecting the program’s correctness.
For Example: If we have a superclass Vehicle with a method startEngine(), and subclasses like Car and ElectricCar, we should be able to replace Vehicle with Car or ElectricCar in our system without any functionality breaking. If ElectricCar can't implement startEngine() because it doesn’t have a traditional engine, it should still work with the interface to not break the system.
'I' for Interface Segregation Principle: It means do not force any client to depend on methods it does not use; split large interfaces into smaller ones.
For Example: Instead of one large interface VehicleOperations with methods like drive, refuel, charge, and navigate, split it into focused interfaces like Drivable, Refuelable, and Navigable. An ElectricCar wouldn't need to implement Refuelable, just Chargeable and Navigable.
'D' stands for Dependency Inversion Principle: It means High-level modules should not depend directly on low-level modules but should communicate through abstractions like interfaces.
For Example: If a VehicleTracker class needs to log vehicle positions, it shouldn't depend directly on a specific GPS device model. Instead, it should interact through a GPSDevice interface, allowing any GPS device that implements this interface to be used without changing the VehicleTracker class.


Concurrency and multi-threading
<p><b>What is a thread in Java and how can we create it?</b></p>
A thread in Java is a pathway of execution within a program. You can create a thread by extending the Thread class or implementing the Runnable interface.
<p><b>Can you explain the lifecycle of a Java thread?</b></p>
A Java thread lifecycle includes states: New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated.

 
<p><b>How would you handle a scenario where two threads need to update the same data structure?</b></p>
Use synchronized blocks or methods to ensure that only one thread can access the data structure at a time, preventing concurrent modification issues.
<p><b>Can we strat thread twice?</b></p>
No, a thread in Java cannot be started more than once. Attempting to restart a thread that has already run will throw an IllegalThreadStateException.

<p><b>What is the difference between Thread class and Runnable interface in Java?</b></p>
The Thread class defines a thread of execution, whereas the Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.

<p><b>How can you ensure a method is thread-safe in Java?</b></p>
To ensure thread safety, use synchronization mechanisms like synchronized blocks, volatile variables, or concurrent data structures.
<p><b>What are volatile variables?</b></p>
Volatile variables in Java are used to indicate that a variable's value will be modified by different threads, ensuring that the value read is always the latest written.

<p><b>What is thread synchronization and why is it important?</b></p>
Thread synchronization controls the access of multiple threads to shared resources to prevent data inconsistency and ensure thread safety.
<p><b>Can you describe a scenario where you would use wait() and notify() methods in thread communication?</b></p>
Use wait() and notify() for inter-thread communication, like when one thread needs to wait for another to complete a task before proceeding.
<p><b>What challenges might you face with multithreaded programs in Java?</b></p>
In Java, multithreaded programming can lead to issues like deadlocks, race conditions, and resource contention, which complicate debugging and affect performance. Managing thread safety and synchronization efficiently is also a significant challenge.

<p><b>What is Java memory model and how it is linked to threads?</b></p>
The Java Memory Model (JMM) defines the rules by which Java programs achieve consistency when reading and writing variables across multiple threads, ensuring all threads have a consistent view of memory.



Miscellaneous questions (Not too much important)


 
<p><b>what is transient?</b></p>
The transient keyword in Java is used to indicate that a field should not be serialized. This means it will be ignored when objects are serialized and deserialized.

<p><b>Can we create a server in java application without creating spring or any other framework?</b></p>
Yes, you can create a server in a Java application using only Java SE APIs, such as by utilizing the ServerSocket class for a simple TCP server or the HttpServer class for HTTP services.


<p><b>What is exchanger class</b></p>
The Exchanger class in Java is a synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on exchange and receives another object in return from another thread.
<p><b>What is reflection in java?</b></p>
Reflection in Java is a capability to inspect and modify the runtime behavior of applications. It allows programs to manipulate internal properties of classes, methods, interfaces, and dynamically call them at runtime.
<p><b>What is the weak reference and soft reference in java?</b></p>
Weak references in Java are garbage collected when no strong references exist. Soft references are only cleared at the discretion of the garbage collector, typically when memory is low.

<p><b>What is Java Flight Recorder?</b></p>
Java Flight Recorder (JFR) is a tool for collecting diagnostic and profiling data about a running Java application without significant performance overhead.
<p><b>Discuss Java Generics.</b></p>
Generics provide type safety by allowing classes and methods to operate on objects of specific types, preventing runtime ClassCastException and reducing code duplication
<p><b>What is the difference between Young Generation and Old Generation memory spaces?</b></p>
The Young Generation stores newly created objects. The Old Generationholds objects that have survived several garbage collection cycles in the Young Generation

							</div>
					
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../springboot/introduction.html">Java_3</a>
					</div>
					
					<div class="toggle-content">
								<p>Index

1)	Describe a scenario where you used a PriorityQueue, and explain why it was chosen over other types of queues.
I used a PriorityQueue in a scenario where I needed to manage tasks by their priority, not just by the order they arrived. This type of queue helped in automatically sorting tasks such that the most critical ones were handled first. Unlike regular queues that process tasks in the order they come
(FIFO), PriorityQueue sorts them based on their urgency, making it ideal for situations where some tasks are more important than others.


2)	What are enums in Java and how are they useful?
Enums in Java are special types used to define a set of fixed constants, like days of the week or
directions (NORTH, SOUTH, etc.). They are useful because they make the code more readable and prevent errors by limiting the possible values for a variable. Instead of using random numbers or strings, enums ensure only predefined values are used, improving code clarity and safety.


3)	What is the Builder Pattern in Java? How is it different from the Factory Pattern?
The Builder Pattern in Java is used to construct complex objects step by step, allowing different parts of an object to be built independently and then assembled as a final step. It's different from the
Factory Pattern, which is used to create objects without exposing the creation logic to the client. The Builder Pattern gives more control over the construction process, whereas the Factory Pattern focuses on creating a finished object in a single step.


4)	What is the impact of declaring a method as final on inheritance?
Declaring a method as final in Java prevents it from being overridden in any subclass. This is useful when you want to ensure that the functionality of a method remains consistent and unchanged,
regardless of inheritance. It provides a safeguard that the method will behave the same way, even in derived classes, maintaining the original behavior and preventing any alteration or unexpected behavior in the program.

 
5)	Can method overloading be determined at runtime?
No, method overloading cannot be determined at runtime; it is resolved at compile-time. Method overloading occurs when multiple methods have the same name but different parameters within the same class. The compiler determines which method to use based on the method signature (method name and parameter types) when the code is compiled. This is unlike method overriding, where the method to execute is determined at runtime based on the object’s actual class type.


6)	How does Java resolve a call to an overloaded method?
Java resolves a call to an overloaded method at compile time by looking at the method signature, which includes the method name and the types and number of parameters. The compiler matches
the arguments used in the method call to the parameters of the defined methods. It selects the most specific method that fits the arguments provided. If there's no exact match or it's ambiguous, the compiler will throw an error.



7)	What is the diamond operator, and how does it work?
The diamond operator in Java, introduced in Java 7, simplifies the notation of generics by reducing
the need to duplicate generic type parameters. For instance, instead of writing List<String> list = new ArrayList<String>();, you can use the diamond operator: List<String> list = new ArrayList<>();. The compiler infers the type parameter String for the ArrayList based on the variable's declared type, making the code cleaner and easier to read.


8)	Explain inner classes in Java.
Inner classes in Java are classes defined within another class. They are useful for logically grouping classes that will only be used in one place, increasing encapsulation. Inner classes have access to the attributes and methods of the outer class, even if they are declared private. There are several types: non-static nested classes (inner classes), static nested classes, local classes (inside a method), and anonymous classes (without a class name). Each type serves different purposes based on the specific need for grouping and scope control.


9)	Can inner classes have static declarations?
Inner classes in Java can have static declarations if they are themselves declared as static. These static nested classes can contain static methods, fields, or blocks. However, non-static inner classes, which are associated with an instance of the outer class, cannot contain any static members. The reason is that static members belong to the class rather than an instance, and non-static inner classes are intimately linked to the outer class's instance.



 
10)	What is the significance of an anonymous inner class?
Anonymous inner classes in Java are useful when you need to implement an interface or extend a class without creating a separate named class. They are defined and instantiated all at once, typically at the point of use. This is particularly helpful for handling events or creating runnable objects in GUI applications with minimal code. By using anonymous inner classes, developers can make their code more concise and focused on specific tasks.


11)	What do you think Java uses: pass by value or pass by reference?
Java uses pass by value. This means when you pass a variable to a method, Java copies the actual value of an argument into the formal parameter of the function. For primitive types, Java copies the actual values, while for objects, Java copies the value of the reference to the object. Therefore, changes made to the parameter inside the method do not affect the original value outside the method.


12)	What are the differences between implementing Runnable and extending Thread in Java?
In Java, implementing the Runnable interface and extending the Thread class are two ways to create a thread, but they serve different purposes. Implementing Runnable is generally preferred as it
allows a class to extend another class while still being able to run in a thread, promoting better object-oriented design and flexibility. Extending Thread makes a class unable to extend any other class due to Java's single inheritance limitation, but it can be simpler for straightforward scenarios.


13)	What is a marker interface?
A marker interface in Java is an interface with no methods or fields. It serves to provide runtime information to objects about what they can do. Essentially, it "marks" a class with a certain property, allowing the program to use instanceof checks to trigger specific behavior based on the presence of the marker. Examples include Serializable and Cloneable, which indicate that a class is capable of
serialization or cloning, respectively.


14)	Can you provide a scenario where creating a custom marker interface would be beneficial?
Creating a custom marker interface can be beneficial in scenarios where you want to enforce a special handling or policy for certain classes without adding any actual methods. For example,
consider a security system where only certain data objects can be transmitted over a network. You could define a marker interface like Transmittable. By implementing this interface in certain classes, you can use instanceof to check and ensure that only objects of these classes are transmitted, enhancing security controls.


15)	How does Java determine which method to call in the case of method overloading?
In the case of method overloading, Java determines which method to call based on the method's signature. This includes the method name and the number and types of parameters. The compiler

 
looks at the arguments passed during the method call and matches them to the method that has the corresponding parameter types. If it finds an exact match, it executes that method. If it doesn’t find a match or if the call is ambiguous, it results in a compile-time error.


16)	What happens if two packages have the same class name?
If two packages in Java contain a class with the same name, you can still use both classes in your program, but you must manage them carefully to avoid naming conflicts. To differentiate between the two, you should use the fully qualified name of the classes, which includes the package name followed by the class name, in your code. For example, package1.ClassName and
package2.ClassName. This approach clarifies which class you intend to use from each package.


17)	How do you access a package-private class from another package?
In Java, a package-private class, which is declared without any access modifiers, is only accessible within the same package. To access such a class from another package, you cannot do so directly due to its limited visibility. The typical solution involves changing the access level of the class to public, making it accessible from other packages. Alternatively, you can add methods or classes within the
same package that can access the package-private class and expose its functionality publicly or through interfaces.


18)	Can you modify a final object reference in Java?
In Java, when you declare an object reference as final, you cannot change the reference to point to a different object after it has been assigned. However, the object itself can still be modified if it is mutable. This means that while you can't reassign the final reference to a new object, you can change the object's properties or state. For instance, you can add items to a final list but cannot
reassign it to another list.


19)	What is the default access modifier if none is specified?
In Java, if no access modifier is specified for a class member (like fields or methods), it defaults to package-private. This means that the member is accessible only within classes that are in the same package. This default access level provides a moderate level of protection within the package and is less restrictive than private, but more restrictive than protected or public, preventing access from outside the package.


20)	What are the potential issues with using mutable objects as keys in a HashMap?
Using mutable objects as keys in a HashMap can lead to significant issues. If the object’s state changes after it’s been used as a key, its hashcode can change, making it impossible to locate in the map even though it's still there. This results in a loss of access to that entry, effectively causing data loss and potential memory leaks. Therefore, it's best to use immutable objects as keys to maintain consistent behavior and reliable access.

 
21)	What would happen if you override only the equals() method and not hashCode() in a custom key class used in HashMap?
If you override only the equals() method without overriding hashCode() in a custom key class used in a HashMap, you'll run into problems. Java requires that equal objects must have the same hash code. If they don’t, the HashMap might not find the object even though it's there. This inconsistency can lead to duplicate keys and unpredictable behavior, as the HashMap uses the hash code to locate keys. Always override both methods to ensure correct behavior.


22)	What is the difference between HashMap and IdentityHashMap in terms of how they handle keys?
The main difference between HashMap and IdentityHashMap is how they handle key comparison. HashMap uses the equals() method and hashCode() to determine if two keys are the same, which checks for logical equality. In contrast, IdentityHashMap uses == for key comparison, which checks
for reference equality. This means IdentityHashMap considers two keys equal only if they are exactly the same object, not merely equal objects. This makes IdentityHashMap suitable for identity-based key operations.


23)	How does Collections.sort() work internally?
Internally, Collections.sort() in Java uses a modified version of the MergeSort algorithm known as TimSort. This algorithm is efficient and stable, meaning it preserves the order of equal elements. It breaks the list into smaller parts, sorts each part, and then merges them back together in sorted order, ensuring that the overall list is ordered. This method is optimized for performance and
reliability, making it suitable for sorting both primitive types and objects based on natural ordering or a specified comparator.


24)	What would happen if you try to sort a list containing null elements using Collections.sort()?
If you try to sort a list containing null elements using Collections.sort(), it will throw a
NullPointerException. This method requires all elements in the list to be non-null and comparable. Null elements lack a comparison order, which prevents Collections.sort() from determining their position relative to other elements. To sort such lists, you must either remove null elements or use a custom comparator that explicitly handles nulls.


25)	Can you sort a list of custom objects using Collections.sort() without providing a Comparator?
Yes, you can sort a list of custom objects using Collections.sort() without providing a Comparator, but only if the custom objects implement the Comparable interface. This interface requires defining a compareTo method, which specifies the natural ordering of the objects. If the objects do not
implement Comparable, or if the compareTo method is not implemented, attempting to sort without a Comparator will result in a ClassCastException.


 
26)	What is the difference between using Collections.sort() and Stream.sorted() in Java 8+?
The difference between Collections.sort() and Stream.sorted() in Java 8+ lies in how they handle data and output. Collections.sort() modifies the list it sorts directly, changing the original data
structure. On the other hand, Stream.sorted() operates on a stream of data and returns a new sorted stream without altering the original source. This makes Stream.sorted() more flexible and suitable for functional programming styles, as it supports chain operations and doesn't affect the original data.


27)	Can an enum extend another class in Java?
No, an enum in Java cannot extend another class. In Java, all enums implicitly extend the
java.lang.Enum class, and since Java does not support multiple inheritance for classes, an enum cannot extend any other class. However, enums can implement interfaces, allowing them to include additional functionality beyond the basic enum capabilities. This provides a way to enhance the functionality of enums without the need for class inheritance.


28)	How do you iterate over all values of an enum?
To iterate over all values of an enum in Java, you can use the values() method, which returns an array of all enum constants in the order they're declared. You can then loop through this array using a for- each loop. Here’s how it works: for each constant in the enum, you perform the desired operation.
This method is straightforward and efficient for accessing and manipulating each constant in an enum type.


29)	Can you serialize static fields in Java?
No, you cannot serialize static fields in Java. Serialization in Java is designed to capture the state of an object, and static fields are not part of any individual object's state. Instead, static fields belong to
the class itself, shared among all instances. When an object is serialized, only the object's instance variables are saved, while static fields are ignored. This ensures that the class's shared state remains consistent and is not duplicated with each object's serialization.


30)	What happens if an exception is thrown during the serialization process?
If an exception is thrown during the serialization process in Java, the serialization fails, and the state of the object being serialized is not saved. Typically, a NotSerializableException is thrown if an object does not support serialization (i.e., it does not implement the Serializable interface). Other exceptions can include IOException for input/output issues. These exceptions prevent the object
from being properly converted into a byte stream, disrupting the storage or transmission of its state.


31)	What happens if your Serializable class contains a member which is not serializable? How do you fix it?

 
If your Serializable class contains a member that is not serializable, you'll encounter a
NotSerializableException when you try to serialize the class. To fix this, you can either make the non- serializable member transient, which means it won't be included in the serialization process, or ensure that the member class also implements the Serializable interface. Alternatively, you can customize the serialization process by providing your own writeObject and readObject methods that handle the non-serializable member appropriately.


32)	What is TypeErasure?
Type Erasure in Java refers to the process by which the Java compiler removes generic type
information from your code after it compiles it, enforcing generic constraints only at compile time and not at runtime. This means that generic type information is not available during the execution of the program. For example, a List<Integer> and a List<String> are just treated as List. This approach helps maintain backward compatibility with older Java versions that do not support generics.


33)	What is a generic type inference?
Generic type inference in Java is a feature that allows the Java compiler to automatically determine, or infer, the types of generic arguments that are necessary for method calls and expressions. This means you don't always have to explicitly specify the generic types when you're coding, which
simplifies your code. For example, when you use the diamond operator (<>) with collections, the compiler can infer the type of the elements in the collection from the context.


34)	Why can’t we create an array of generic types in Java?
In Java, you cannot create an array of generic types because generics do not maintain their type information at runtime due to type erasure. This means that the Java compiler removes all
information related to type parameters and type arguments within a generic at runtime. Arrays, however, need concrete type information at runtime to ensure type safety, which isn't possible with erased generic types. This mismatch prevents the creation of generic arrays to avoid runtime type
errors.


35)	How Are Strings Represented in Memory?
In Java, strings are represented in memory as objects of the String class, which internally uses a
character array to store the string data. Each String object is immutable, meaning once it is created, it cannot be changed. To optimize memory usage, Java maintains a special area called the "String Pool" where literals are stored. If you create a string that already exists in the pool, Java reuses the existing string instead of creating a new one, reducing memory overhead.


36)	What is the difference between Lambda vs. Anonymous Classes?
Lambda expressions and anonymous classes in Java both provide ways to implement methods from a functional interface, but they do so differently. Lambdas are more concise and focused on passing

 
behavior or functionality, often written in a single line of code without a name. Anonymous classes, on the other hand, are more verbose, require a class declaration, and can be used to create instances of interfaces or abstract classes with methods. Lambdas generally lead to clearer, more readable code compared to anonymous classes.


37)	Explain the difference between Stream API map and flatMap?
In Java's Stream API, map and flatMap are functions used for transforming streams. map applies a function to each element of a stream and collects the results in a new stream. For example, converting each string in a stream to its upper case. On the other hand, flatMap is used when each element of the stream is a stream itself, or can be converted into a stream. It "flattens" all these
streams into a single stream. For instance, converting a stream of lists into a stream of elements.


38)	Explain the difference between peek() and map(). In what scenarios should peek() be used with caution?
In Java's Stream API, peek() and map() both operate on elements of a stream, but they serve different purposes. map() transforms each element and returns a new stream containing the
transformed elements. peek(), on the other hand, is mainly for debugging and allows you to perform operations on each element without altering them, returning the same stream. Caution is advised with peek() because its side effects can be unpredictable if used for purposes other than debugging, such as altering the state of objects, which can lead to inconsistent results in the stream's pipeline execution.


39)	How do imports affect compilation and class loading?
Imports in Java simplify code by allowing you to refer to classes from other packages without using their fully qualified names. During compilation, the import statements help the compiler locate and recognize these classes, but they don't affect performance or class loading. Class loading occurs at runtime when a class is first used, regardless of whether it's imported. Imports don't increase
memory usage or slow down the program—they simply make the code more readable and organized.


40)	What is the difference between Import and Static Imports?
The difference between import and static import in Java lies in what they bring into scope. Regular import is used to access classes from other packages without using their fully qualified names, making code cleaner. Static imports, introduced in Java 5, allow direct access to static members
(fields and methods) of a class without qualifying them with the class name. This is useful when you need frequent access to static methods, like Math.sqrt() or constants like PI, simplifying the code.


41)	What is the impact of static imports on code readability and maintainability?



 
Static imports can improve code readability by reducing repetitive class references, making the code more concise. For example, instead of writing Math.PI, you can just use PI. However, overusing static imports can harm maintainability, as it becomes harder to know where methods or constants are coming from, especially in larger projects. The lack of clarity can confuse developers unfamiliar with the code, so static imports should be used sparingly and wisely.


42)	How to choose initial capacity in an ArrayList constructor in a scenario where the list is repeatedly cleared and reused?
When choosing the initial capacity of an ArrayList in a scenario where the list is repeatedly cleared and reused, it's best to base it on the expected maximum size of the list during its heaviest use. This avoids frequent resizing and reallocations, which are costly. Setting the capacity slightly higher than the typical maximum size ensures that the list has enough space without frequent expansions, leading to better performance and memory management.


43)	Can you tell me an example of how objects and classes interact in a real-world application?
In a real-world banking application, a Customer class defines attributes like name and account number. When a user opens an account, an object of the Customer class is created with specific values. These objects interact with methods like deposit, withdraw, and check balance, encapsulating the behavior and data of the customer.


44)	Scenario-Based: How would you handle a situation where you need to compare the content equality of two custom object instances?
To compare the content equality of two custom object instances, override the equals() method in the class. Inside the method, compare the object's fields (like ID, name, or other properties). This ensures that two objects with identical values are considered equal, even if their references differ.


45)	Scenario-Based: Suppose you're storing user session data in a HashMap. How would you ensure thread safety?
To ensure thread safety when storing user session data in a HashMap, you can use
Collections.synchronizedMap() to wrap the HashMap, making it thread-safe by synchronizing access to it. Alternatively, for better performance in highly concurrent environments, you can use
ConcurrentHashMap, which provides thread safety with less locking overhead by allowing
concurrent reads and controlled updates. This ensures that multiple threads can safely access and modify the session data.
Example:
Map<String, SessionData> sessionMap = new ConcurrentHashMap<>();


46)	Can an interface with multiple default methods still be a functional interface?


 
No, an interface with multiple default methods cannot be a functional interface. A functional interface is defined as an interface with only one abstract method, which allows it to be used with lambda expressions. Default methods are concrete (non-abstract), so having multiple default
methods is fine, but as long as there's only one abstract method, the interface can still be functional. Multiple abstract methods would disqualify it as a functional interface.


47)	How does TreeSet sort elements when it stores objects and not wrapper classes?
When a TreeSet stores objects that are not wrapper classes, it uses natural ordering provided by the object's Comparable implementation, if the class implements the Comparable interface. The
compareTo() method in the object defines how to sort the elements. Alternatively, if the objects don't implement Comparable, you can provide a custom Comparator when creating the TreeSet, which specifies how the elements should be ordered. Without this, trying to store unsorted objects would result in a runtime error.


48)	Can an enum extend another class in Java?
No, an enum in Java cannot extend another class. All enums implicitly extend java.lang.Enum, and since Java doesn't allow multiple inheritance for classes, an enum cannot extend any other class. However, an enum can implement interfaces to gain additional functionality. This limitation ensures that enums remain simple, specialized types that represent fixed sets of constants, while still
allowing some flexibility through interfaces.


49)	How do you iterate over all values of an enum?
In Java, you can easily iterate over all the values of an enum using a for-each loop. First, use the values() method provided by the enum. This method returns an array containing all the values of the enum in the order they're declared. Then, use a for-each loop to go through each element in this
array. Here, you treat each enum value as an element of the array and perform any operations inside the loop.


50)	How does TreeSet sort elements when it stores objects and not wrapper classes?
In Java, a TreeSet sorts objects based on natural ordering or a custom comparator. For natural ordering, the class of the objects stored in the TreeSet must implement the Comparable interface. This interface requires a method called compareTo that defines the order. If the objects don't have natural ordering, you can provide a Comparator when creating the TreeSet, specifying how to compare and sort the objects.


51)	Suppose you have multiple interfaces with default methods that a class implements. How would you resolve method conflicts?
When a class implements multiple interfaces that have default methods with the same signature, you must resolve the conflict by overriding the method in your class. In the overridden method, you

 
can explicitly choose which interface's default method to use by using the syntax InterfaceName.super.methodName(). This tells your class exactly which version of the conflicting method to execute, thus resolving the ambiguity.


52)	How do JVM optimizations affect the performance of Java applications?
JVM optimizations significantly enhance the performance of Java applications by improving execution efficiency. The JVM uses techniques like Just-In-Time (JIT) compilation, which converts Java bytecode into native machine code that runs faster on the processor. It also employs methods like garbage
collection optimization and inlining functions to reduce memory usage and execution time. These optimizations help Java programs run faster and more smoothly, making efficient use of system resources.


53)	Can ‘this’ be used in a static method or block?
No, the keyword this cannot be used in a static method or block in Java. The reason is that this refers to the current instance of a class, and static methods or blocks do not belong to any instance but to the class itself. Since static methods can be called without creating an instance of the class, there's no this context available in static contexts.


54)	Explain Java Class Loader.
The Java Class Loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. It does this when the class is needed for the first time, not at program start, enhancing efficiency. Java uses multiple class loaders in a hierarchy: Bootstrap, Extension, and System/Application. This mechanism helps in separating the namespace of the classes loaded by
different class loaders, preventing conflicts.


55)	Is it possible to unload a class in Java?
In Java, directly unloading a class is not possible as Java does not provide explicit control over the unloading of classes. However, a class can be unloaded when its class loader is garbage collected. This happens if there are no active references to the class and its class loader from any part of the program. Essentially, for a class to be eligible for unloading, all instances of the class and the class loader itself must no longer be in use.


56)	How does class loading affect memory usage?
Class loading in Java affects memory usage by increasing it each time a class is loaded into the JVM.
Each class needs memory for its metadata, methods, and associated objects. This loading is
necessary for the JVM to use the class, but if many classes are loaded, or large libraries are in use, memory consumption can increase significantly. Proper management of class loaders can help in optimizing memory usage, especially in large applications.


 
57)	Can you serialize static fields in Java?
In Java, static fields are not serialized. Serialization in Java is focused on saving the state of an object, and static fields are part of the class state, not individual object state. Therefore, static fields are common to all instances of the class and remain unchanged based on individual object serialization. When you deserialize an object, the static fields will have the values set by the current running program or their initial values as defined in the class.


58)	What is the role of ExecutorService in the Executor Framework? What methods does it provide?
The ExecutorService in the Java Executor Framework plays a crucial role in managing and controlling thread execution. It provides a higher-level replacement for working directly with threads, offering methods to manage lifecycle operations like starting, running, and stopping threads efficiently. Some key methods it provides include submit() for executing callable tasks that return a result, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully once tasks are completed.




Java 8


1)	What are the new features introduced in Java 8?
Java 8 introduced several significant features that enhanced the language's capabilities and performance. Key additions include Lambda Expressions for concise and functional-style programming, the Stream API for efficient data processing, and the new Date and Time API for
improved date handling. Java 8 also introduced default and static methods in interfaces, allowing more complex interface designs, and the Optional class to better handle null values. These features collectively made Java more flexible and powerful, especially for handling collections and
concurrency.


2)	What is a lambda expression in Java 8, and what are its benefits?
Lambda expressions in Java 8 are a way to implement methods from functional interfaces (interfaces with a single abstract method) in a clear and concise manner, using an arrow syntax. The benefits of lambda expressions include reducing the amount of boilerplate code, enhancing readability, and making it easier to use functional programming patterns. They are particularly useful for simplifying code when using collections and APIs that support concurrency, such as the Stream API.


3)	What is the difference between a Lambda Expression and an Anonymous Inner Class?


 
Lambda expressions and anonymous inner classes in Java both enable you to implement methods without declaring a formal class, but they differ significantly in simplicity and functionality. Lambda expressions are more concise and focus on passing a single piece of functionality, typically to a single method in a functional interface. In contrast, anonymous inner classes are more verbose and can
implement multiple methods from an interface or subclass. Lambda expressions also do not have their own scope, unlike anonymous inner classes, which can shadow variables from the enclosing class.


4)	What is a Functional Interface in Java 8?
In Java 8, a Functional Interface is an interface that contains only one abstract method. These interfaces are intended for use with lambda expressions, which provide the implementation of the abstract method. Functional Interfaces can include other default or static methods without affecting their status. The @FunctionalInterface annotation, although not required, can be used to indicate that an interface is intended to be a Functional Interface, helping to avoid accidental addition of abstract methods in the future.


5)	What are some of the predefined functional interfaces in Java 8?
Java 8 introduced several predefined functional interfaces to facilitate lambda expressions and method references. Key examples include Consumer, which accepts a single input and returns no result; Supplier, which provides a result without accepting any input; Function, which takes one argument and returns a result; Predicate, which takes one argument and returns a boolean; and
BiFunction, which takes two arguments and returns a result. These interfaces streamline the creation of lambda expressions for common functional programming patterns.


6)	What is the Streams API in Java 8? How does it work?
The Streams API in Java 8 is a powerful tool for processing sequences of elements in a declarative way. It works by providing a high-level abstraction for performing operations like filtering, mapping, sorting, and more, on collections of objects without modifying the underlying data source. Streams can be sequential or parallel, allowing for efficient data processing. The API emphasizes readability and simplicity, using functional-style operations that leverage lambda expressions for concise and expressive coding.


7)	Explain the difference between map() and flatMap() in Streams.
In Java Streams, map() and flatMap() are both transformation functions but serve different purposes. map() takes a function and applies it to each element in the stream, returning a stream of the results—essentially transforming each element into a new form. Conversely, flatMap() also applies a function to elements, but each function result is expected to be a stream itself; flatMap() then "flattens" these multiple streams into a single stream. This is particularly useful for handling nested collections or arrays.



 
8)	How can you filter a collection using Streams in Java 8?
In Java 8, you can filter a collection using the Streams API by converting the collection to a stream, applying a filter() method, and then specifying a condition within the filter method. The filter() method takes a predicate, which is a functional interface representing a condition that each element of the stream must meet. Elements that satisfy the predicate are retained in the stream, while others are discarded. You can then collect these filtered elements into a new collection if needed.


9)	What are Default Methods in Java 8, and why were they introduced?
Default methods in Java 8 are methods added to interfaces that include an implementation. They
were introduced to enable new functionality in interfaces without breaking existing implementations of these interfaces. This feature allows Java to add enhancements to the standard libraries (like the Collections API) while ensuring backward compatibility with older versions. Default methods help evolve interfaces over time without disrupting the classes that implement these interfaces.


10)	How are Static Methods in interfaces different from Default Methods in Java 8?
In Java 8, static methods in interfaces allow the interface to define methods that can be called on the interface itself, not on instances of classes that implement the interface. This is similar to static methods in classes. Conversely, default methods are methods within an interface that have an
implementation. They can be called on instances of classes that implement the interface, providing default behavior without requiring the implementing class to override the method. Static methods help in utility or helper functionality, while default methods aid in enhancing interfaces without breaking existing implementations.


11)	What is Optional in Java 8, and how is it used?
Optional in Java 8 is a container object used to represent the presence or absence of a value,
effectively reducing the problems caused by null references (often termed the billion-dollar mistake). It provides a way to express optional values without using null. This approach helps prevent
NullPointerExceptions when accessing values that might not exist. Optional is commonly used in situations where a method might return a meaningful value or no value at all, allowing developers to handle the absence of a value gracefully using methods like isPresent(), ifPresent(), and orElse().


12)	How do you handle null values in Java 8 using Optional?
In Java 8, Optional is used to handle null values gracefully. You can create an Optional object that may or may not contain a non-null value by using methods like Optional.ofNullable(). This method returns an Optional object that is either empty (if the value is null) or contains the value. You can then use methods like orElse() to provide a default value if the Optional is empty, or ifPresent() to execute a block of code only if a value is present. This approach helps avoid NullPointerException and makes your code cleaner and safer.



 
13)	What is the difference between findFirst() and findAny() in Streams?
In Java Streams, findFirst() and findAny() are terminal operations that return an Optional describing an element of the stream. findFirst() returns the first element in the stream according to the
encounter order, which is particularly useful in sequential streams. On the other hand, findAny() can return any element from the stream and is more performance-efficient in parallel streams, as it
allows more flexibility in which element is returned, potentially reducing the time spent on synchronous operations.


14)	Explain the purpose of the Collectors class in Java 8.
The Collectors class in Java 8 serves as a utility to help with common mutable reductions and
collection operations on streams, like grouping elements, summarizing elements, or converting them into collections like Lists, Sets, or Maps. It provides a set of pre-defined static methods that can be used with the collect() method of the Stream API. This makes it easy to perform complex tasks like joining strings, averaging numbers, or categorizing items in a streamlined and efficient manner.


15)	What is the significance of the forEach() method in Java 8?
The forEach() method in Java 8 is significant for its ability to simplify iterations over collections, including those that are part of the Java Collections Framework or arrays. Implemented as a default method in the Iterable interface and as a terminal operation in the Stream API, forEach() allows you to execute a specific action on each element of a collection or stream. This method enhances readability and reduces boilerplate code associated with traditional for-loops, making operations more concise and expressive, especially when combined with lambda expressions.



16)	How does Java 8 handle parallel processing with the Streams API?
Java 8 enhances parallel processing capabilities through the Streams API, which allows for easy
parallelization of operations on collections. By invoking the parallelStream() method on a collection, you can create a parallel stream that divides the data into multiple parts, which are processed
concurrently across different threads. This leverages multicore processors effectively to improve performance for large data sets. The framework handles the decomposition and merging of data, simplifying parallel execution without the need for explicit thread management.


17)	What is the purpose of the Predicate functional interface in Java 8?
The Predicate functional interface in Java 8 is designed to represent a boolean-valued function of one argument. Its primary purpose is to evaluate a given predicate (a condition that returns true or false) on objects of a specific type. Predicates are often used for filtering or matching objects. For example, in the Streams API, the filter() method uses a Predicate to determine which elements should be included in the resulting stream based on whether they satisfy the predicate. This functionality is crucial for conditional operations in collection processing.


 
18)	How do you create an infinite stream in Java 8?
In Java 8, you can create an infinite stream using the Stream.iterate or Stream.generate methods. Stream.iterate repeatedly applies a given function to a seed value to produce an infinite sequence, for example, generating an infinite stream of natural numbers by successively adding one.
Stream.generate takes a Supplier to provide new values and produces an infinite stream of those values. Both methods yield infinite streams that require limiting actions to prevent endless processing.


19)	What is the Function interface in Java 8, and how is it used?
The Function interface in Java 8 is a functional interface that represents a function that accepts one argument and produces a result. It is commonly used for transforming objects of one type into
another, such as converting strings to integers or applying mathematical operations to numbers. The interface is generic, allowing for flexibility in specifying the types of the input and output. In the
Streams API, the Function interface is often passed to the map() method to transform stream elements.


20)	What are method references in Java 8, and how do they relate to Lambda Expressions?
Method references in Java 8 are a shorthand notation of lambda expressions that refer directly to methods by their names. They serve as a clean and concise way to express instances where lambda expressions simply call existing methods. For example, instead of using a lambda like (x) ->
System.out.println(x), you can use the method reference System.out::println. This syntax directly points to the println method, improving code clarity and reducing verbosity when interfacing with functional interfaces.


21)	How can you sort a collection using Streams in Java 8?
In Java 8, you can sort a collection using the Streams API by converting the collection into a stream, applying the sorted() method, and then collecting the results back into a collection. The sorted() method can be used without arguments to sort in natural order, or with a comparator if a specific sorting order is needed. Finally, you use the collect(Collectors.toList()) (or another appropriate
collector) to gather the sorted elements back into a collection like a list or set. This method provides a fluent, functional approach to sorting data.


22)	What is the use of reduce() in Java 8 Streams?
The reduce() method in Java 8 Streams is used to combine all elements of the stream into a single result. This method takes a binary operator as a parameter, which is used to accumulate the
elements of the stream. Reduce() is useful for performing operations like summing all numbers in a list, finding the maximum or minimum value, or accumulating elements into a single result. This method essentially reduces a stream of elements to one summary result based on the provided operation.

 
23)	How does the filter() method work in Java 8?
The filter() method in Java 8's Streams API is used to evaluate each element in a stream against a given predicate, which is a functional interface that defines a condition returning a boolean value. Elements that pass this condition (i.e., for which the predicate returns true) are included in the resulting stream, while those that do not pass are discarded. This method is particularly useful for extracting subsets of data from collections based on specific criteria.


24)	What is the significance of Collectors.toList() in Java 8 Streams?
In Java 8, Collectors.toList() is a collector used in the Stream API to gather stream elements into a new list. This method is typically used with the collect() terminal operation to accumulate the
elements of a stream into a list after performing operations like filtering, mapping, or sorting. It simplifies the process of converting a stream back into a collection, making it highly useful for collecting processed data conveniently and efficiently into a commonly used data structure.


25)	Can you explain how Stream.of() works in Java 8?
In Java 8, Stream.of() is a static method used to create a stream from a set of individual objects. You can pass one or more objects to this method, and it will return a stream containing the elements you provided. This is particularly useful for quickly turning a few elements into a stream without needing to create a collection first. It's a convenient way to work with a fixed number of elements for stream operations like filtering, mapping, or collecting.



26)	How is Java 8 backward-compatible with earlier versions of Java?
Java 8 maintains backward compatibility with earlier versions by ensuring that existing interfaces can be expanded with new features—like lambda expressions, method references, and stream APIs— without breaking the implementations that depend on older versions. For example, the introduction of default methods in interfaces allows new methods to be added without requiring changes in the
implementing classes. This design approach ensures that older Java applications can still run without modification in the newer Java 8 environment.


27)	What is the difference between limit() and skip() in Java 8 Streams?
In Java 8 Streams, limit() and skip() are two intermediate operations that manage the size of the stream. limit(n) is used to truncate the stream so that it contains no more than n elements,
effectively limiting the number of items processed downstream. On the other hand, skip(n) discards the first n elements of the stream, allowing the stream to start processing from the element that
follows. Together, these methods help in controlling stream flow for specific processing needs.



 
28)	Explain how to convert a list to a map using Streams in Java 8.
In Java 8, you can convert a list to a map using the Streams API by utilizing the
collect(Collectors.toMap()) method. First, convert the list into a stream. Then, use toMap() where you specify functions for determining the keys and values for the map. For example, if you have a list of objects, you might use an attribute of the objects as the key and the objects themselves as values. This method effectively organizes elements of a list into a map based on defined criteria.


29)	What is the difference between Stream.iterate() and Stream.generate()?
Stream.iterate() and Stream.generate() in Java 8 are both methods for creating infinite streams, but they do so in different ways. Stream.iterate() takes a seed (initial value) and a function, applying the function repeatedly to generate a sequence (e.g., creating a stream of powers of two).
Stream.generate(), on the other hand, uses a supplier to provide new values, which doesn't depend on the previous element. This makes Stream.generate() suitable for generating streams where each element is independent of the others.


30)	How can you apply a custom comparator in a stream pipeline in Java 8?
In Java 8, you can apply a custom comparator in a stream pipeline using the sorted() method. First, define your comparator, which dictates how the elements should be compared based on your custom criteria. Then, pass this comparator to the sorted() method within your stream pipeline. For example, if you're streaming a list of objects, you can sort them by a specific attribute using a comparator that compares that attribute. This method integrates seamlessly into the stream,
allowing for flexible sorting within the pipeline.




31)	Can you explain why Java 8 introduced the concept of Default Methods in interfaces, and what problem does it solve?
Java 8 introduced default methods in interfaces to enable interfaces to evolve while maintaining backward compatibility with older versions. Previously, adding a new method to an interface
required all implementing classes to define that method, potentially breaking existing applications.
Default methods allow new functionalities to be added to interfaces without obligating
implementing classes to change. This helps in enhancing interfaces with new methods while ensuring that existing implementations do not fail.


32)	Is it possible to use this and super in a Lambda expression? Explain why or why not.
In Java, within lambda expressions, this and super keywords do not refer to the lambda expression itself but rather to the enclosing instance where the lambda is defined. This means this refers to the instance of the class where the lambda is created, and super refers to the superclass of this instance. Therefore, while you can use this and super in lambda expressions, they do not behave as they might be expected to within traditional methods or anonymous inner classes, where they refer directly to
the current or parent class object respectively.

 
33)	How can a Lambda expression access variables outside its scope? What is the concept behind it?
Lambda expressions in Java can access variables outside their scope, specifically final or effectively final variables from their enclosing scope. An effectively final variable is one that is not modified after initialization. This restriction ensures that the lambda expression is state-consistent and can be safely called multiple times without side effects that could arise from modifying external variables. This capability allows lambda expressions to capture and use local variables in a functional-style
programming approach, enhancing their utility and flexibility.


34)	Can a Lambda expression throw an exception? How can you handle exceptions in a Lambda?
Yes, lambda expressions in Java can throw exceptions, just like regular methods. However, if the functional interface the lambda is implementing does not declare an exception, any checked exceptions thrown within the lambda must either be caught or converted to unchecked exceptions. To handle exceptions directly within a lambda, you can use a try-catch block surrounding the code that might throw the exception. This approach allows the lambda to manage exceptions internally without affecting the external execution flow.


35)	What is the difference between Optional.of() and Optional.ofNullable()?
In Java, Optional.of() and Optional.ofNullable() are methods used to create Optional objects, but they handle null values differently. Optional.of(value) requires a non-null value and throws a
NullPointerException if passed a null. This is suitable when you are certain the value is not null. In contrast, Optional.ofNullable(value) is safe for use with values that might be null. It returns an empty Optional if the value is null, thus avoiding any exceptions.



36)	How does the internal working of Stream.sorted() differ when using natural ordering versus custom comparator?
The Stream.sorted() method in Java sorts the elements of a stream either using natural ordering or a custom comparator. When using natural ordering, it assumes that the stream elements implement
the Comparable interface and sorts them according to their compareTo method. With a custom comparator, you provide a Comparator object that defines a different sorting logic. This allows for flexibility in sorting based on attributes or rules that do not adhere to the natural order of the
elements. Both methods internally use efficient sorting algorithms optimized for performance and stability.


37)	Can you use Optional as a method parameter? Why should or shouldn’t you do this?
Using Optional as a method parameter in Java is technically possible but generally discouraged. The primary purpose of Optional is to provide a more expressive alternative to null references and to

 
enhance readability and safety in APIs by clearly indicating that a method might not return a value. Using Optional as a parameter complicates method signatures and usage, potentially obscuring intent and leading to less clean code. Instead, it's better to use Optional for return types where it
clarifies that a method might not produce a value.


38)	What will happen if you try to modify a local variable inside a Lambda expression?
In Java, if you try to modify a local variable inside a lambda expression, you'll encounter a compile- time error. Local variables accessed from within a lambda must be final or effectively final—meaning once they are initialized, they cannot be modified. This restriction ensures that the lambda does not introduce side effects by altering the local environment, preserving thread safety and functional programming principles where functions do not modify the state outside their scope.


39)	Can you use the synchronized keyword inside a Lambda expression?
No, you cannot directly use the synchronized keyword inside the body of a lambda expression in Java. Lambda expressions are meant to be short, stateless, and concise blocks of code. They do not have an intrinsic lock object to synchronize on, unlike methods in a class. If synchronization is
necessary within a lambda, you must handle it externally, such as synchronizing on an external object or using higher-level concurrency utilities provided by Java.


40)	What is the difference between count(), sum(), and reduce() in Java 8 Streams?
In Java 8 Streams, count(), sum(), and reduce() serve different purposes: count() simply returns the number of elements in the stream, useful for tallying items. sum(), available in specialized stream
types like IntStream, LongStream, and DoubleStream, calculates the total of the elements. reduce(), on the other hand, is a more general method that combines all elements in the stream using a provided binary operator to produce a single result, allowing for more complex accumulations beyond just summing.





Concurrency and Multithreading



1)	How would you ensure that a shared resource is accessed safely by multiple threads?
To ensure safe access to a shared resource by multiple threads in Java, you can use synchronization. This involves using the synchronized keyword to lock an object or a method while a thread is using it. Only one thread can hold the lock at a time, preventing other threads from accessing the locked code


 
until the lock is released. This mechanism helps avoid conflicts and data corruption by ensuring that only one thread can modify the shared resource at any given time.


2)	Explain the synchronized keyword in Java. How does it work?
The synchronized keyword in Java is used to control access to a critical section of code by locking an object or method so that only one thread can execute it at a time. When a thread enters a
synchronized block or method, it obtains a lock on the specified object or class, preventing other threads from entering any synchronized blocks or methods that lock the same object or class until the lock is released. This ensures that the shared data is accessed in a thread-safe manner.


3)	What are the differences between using synchronized on a method versus on a block of code?
Using synchronized on a method locks the entire method, so when a thread enters this method, no other thread can enter any synchronized method of that object until the lock is released. However, using synchronized on a block of code only locks that specific block. This allows finer control over which parts of the code need synchronization, potentially improving performance by reducing the scope of locking to just critical sections of the code.


4)	What is the significance of the volatile keyword in Java concurrency?
The volatile keyword in Java concurrency is crucial for ensuring visibility and preventing caching of variables across threads. When a variable is declared as volatile, it tells the JVM that every read or write to that variable should go directly to main memory, bypassing any intermediate caches. This ensures that changes made to a volatile variable by one thread are immediately visible to other
threads, maintaining data consistency across threads without using synchronized blocks.


5)	How does the introduction of Lambda expressions change the way Java handles concurrency?
Lambda expressions in Java simplify the way concurrency is handled primarily by reducing the verbosity and complexity of anonymous classes, making code more readable and concise. They facilitate the use of functional programming techniques within Java, particularly in dealing with concurrency frameworks like Streams and CompletableFuture, which rely heavily on passing behaviors (functions) as arguments. Lambdas enable cleaner and more maintainable concurrent processing by allowing developers to focus on the logic rather than boilerplate code.


6)	Explain the Java concurrency model.
The Java concurrency model is built around threads, which are units of execution within a process. Java provides a rich set of tools and APIs, like Thread class, Runnable interface, and concurrency utilities in the java.util.concurrent package, to manage and synchronize these threads. This model
allows multiple threads to run in parallel, enhancing performance especially in multi-core processors. Synchronization and coordination between threads are achieved through mechanisms like locks,


 
synchronized blocks/methods, and concurrent data structures, ensuring safe communication between threads.


7)	What are the challenges associated with Java’s thread management?
Java's thread management presents several challenges, including the complexity of ensuring thread safety, which requires careful synchronization to avoid issues like data corruption and deadlocks.
Managing thread life cycles and resource allocation efficiently can also be difficult, as threads
consume system resources. Overuse of threading can lead to high CPU usage and slower application performance. Additionally, debugging multithreaded applications is often more complex due to the unpredictable nature of thread execution.


8)	Can volatile variables be used as a replacement for synchronization?
Volatile variables cannot fully replace synchronization in Java. While they ensure that the value of a variable is consistently updated across all threads (ensuring visibility), they do not provide the
mutual exclusion necessary for complex synchronization. For operations that go beyond the simple reading and writing of a single variable, such as incrementing a counter or checking and modifying multiple variables, synchronized blocks or locks are necessary to prevent race conditions and ensure data integrity.


9)	Can a deadlock occur with a single thread?
A deadlock typically involves two or more threads, where each thread is waiting for another to release a resource they need. However, a single thread can experience a similar issue called a self-
deadlock or resource starvation if it recursively acquires a non-reentrant lock it already holds without releasing it first. This situation causes the thread to wait indefinitely for its own lock to be released, effectively deadlocking itself. Such cases are rare and usually result from programming errors.


10)	What is a synchronized collection, and how does it differ from a concurrent collection?
A synchronized collection in Java is a standard collection that has been wrapped with synchronization to make it thread-safe, meaning only one thread can access it at a time. This is typically achieved using methods like Collections.synchronizedList(). In contrast, a concurrent collection, like those found in the java.util.concurrent package, is designed specifically for concurrent access and usually
allows multiple threads to access and modify it simultaneously with better performance due to finer- grained locking or lock-free mechanisms.


11)	How does Java handle multi-threading?
Java handles multi-threading by allowing multiple threads to run concurrently within a single
application, using the Thread class and the Runnable interface to define and manage threads. Java provides built-in support for thread lifecycle management, synchronization, and inter-thread communication to ensure threads operate safely without interfering with each other. The Java

 
concurrency API, including utilities like ExecutorService and ConcurrentHashMap, further simplifies multi-threaded programming and enhances performance and scalability.


12)	What are the differences between Runnable and Callable in Java concurrency?
In Java concurrency, both Runnable and Callable interfaces are used to execute tasks
asynchronously, but they differ in key ways. Runnable has a run() method that does not return a result and cannot throw checked exceptions. In contrast, Callable includes a call() method that returns a result and can throw checked exceptions. This makes Callable more versatile for tasks where you need to handle outcomes and exceptions or require a result upon completion.


13)	How do you handle thread interruption in Java?
In Java, thread interruption is a cooperative mechanism used to signal a thread that it should stop its current tasks. To handle an interruption, the thread must regularly check its interrupted status by
calling Thread.interrupted() or isInterrupted(). When an interruption is detected, the thread should stop its operations cleanly. It's important to manage any ongoing tasks and resources properly during this process to ensure that the thread terminates without leaving unfinished tasks or resource leaks.



14)	How do you check if a Thread holds a lock or not?
In Java, you can check if a specific thread holds a lock by using methods from the Thread class or related classes. However, directly checking if a thread holds a particular object lock isn't
straightforward without additional tools or frameworks. Generally, you can design your application to track lock acquisition and release, or use debugging tools and APIs provided by Java, like Thread.holdsLock(Object obj), which returns true if the current thread holds the monitor lock on the specified object. This method is useful for debugging and validation purposes.


15)	What are use cases of ThreadLocal variables in Java?
ThreadLocal variables in Java are used to maintain data that is unique to each thread, providing a
thread-safe environment without requiring synchronization. Common use cases include maintaining user sessions in web applications, where each HTTP request is handled by a different thread, or storing data that is specific to a particular thread's execution context, such as a transaction ID or
temporary user credentials. This ensures that each thread has its own instance of a variable, isolated from other threads.


16)	What is the role of ExecutorService in the Executor Framework? What methods does it provide?
The ExecutorService in the Java Executor Framework plays a crucial role in managing and controlling thread execution. It provides a higher-level replacement for working directly with threads, offering methods to manage lifecycle operations like starting, running, and stopping threads efficiently. Some
 
key methods it provides include submit() for executing callable tasks that return a result, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully once tasks are completed.


17)	What is the difference between submit() and execute() methods in the Executor Framework?
In the Java Executor Framework, the submit() and execute() methods both schedule tasks for execution, but they differ in key aspects. The execute() method is used to run Runnable tasks and does not return any result. Conversely, the submit() method can accept both Runnable and Callable tasks, returning a Future object that can be used to retrieve the Callable task’s result or check the status of the Runnable. This makes submit() more flexible and useful for handling tasks that produce results.


18)	What is the RejectedExecutionHandler in ThreadPoolExecutor? How can you customize it?
The RejectedExecutionHandler in a ThreadPoolExecutor in Java is an interface that handles tasks that cannot be executed by the thread pool, typically when the pool is fully utilized and the task queue is full. You can customize it by implementing this interface and defining your own rejectedExecution method. This method decides what to do with the rejected tasks, such as logging them, running
them on a different executor, or implementing a backoff and retry mechanism. This customization allows for more robust handling of task overflows in applications.


19)	How does ConcurrentHashMap work internally?
The ConcurrentHashMap in Java is designed for concurrent access without the extensive use of synchronization. Internally, it divides the data into segments, effectively a hashtable-like structure.
Each segment manages its own lock, reducing contention by allowing multiple threads to
concurrently access different segments of the map. This means that read operations can generally be performed without locking, and writes require minimal locking, significantly increasing performance over a Hashtable or synchronized Map under concurrent access scenarios.


20)	Difference Between synchronized and ReentrantLock?
The synchronized keyword and ReentrantLock both provide locking mechanisms in Java, but they differ in functionality and flexibility. synchronized is easier to use and automatically handles locking and unlocking, but offers less control. In contrast, ReentrantLock provides more advanced features, such as the ability to try to acquire a lock without waiting forever, lock interruptibility, and support for fairness policies. Additionally, ReentrantLock allows multiple condition variables per lock,
facilitating more complex synchronization scenarios.


21)	What happens when an exception occurs inside a synchronized block?
When an exception occurs inside a synchronized block in Java, the lock that was acquired when entering the synchronized block is automatically released. This allows other threads to enter the

 
synchronized block or method once the current thread has exited due to the exception. Essentially, the synchronized mechanism ensures that locks are managed cleanly, even in the event of an exception, preventing deadlocks and allowing program execution to continue in other threads.


22)	How do you get a thread dump in Java?
To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides
detailed information about the threads running in your Java application.


23)	How to get a thread dump in Java?
To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides
detailed information about the threads running in your Java application.


24)	 What are the different ways to achieve synchronization in Java?
In Java, synchronization can be achieved through several methods to ensure thread safety. The
primary way is using the synchronized keyword, which can be applied to methods or blocks of code to restrict access to a resource to one thread at a time. Additionally, Java provides volatile variables to ensure visibility of changes to variables across threads. More sophisticated synchronization can involve using classes from the java.util.concurrent package, like ReentrantLock, Semaphore, and CountDownLatch, which offer more control and flexibility than synchronized.


25)	What is the difference between synchronized method and synchronized block?
In Java, a synchronized method locks the entire method at the object or class level, depending on
whether the method is an instance method or static, ensuring that only one thread can access it at a time. In contrast, a synchronized block provides more granular control by only locking a specific
section of a method or a specific object, which can minimize waiting times for threads and improve performance by reducing the scope of the lock.



Memory Management
1)	How does Java handle memory leaks?
Java handles potential memory leaks primarily through its automatic garbage collection mechanism, which periodically frees up memory used by objects that are no longer accessible in the program.
 
However, memory leaks can still occur if references to objects are unintentionally retained, preventing the garbage collector from reclaiming that memory. Developers must be vigilant about managing resources, such as closing files and network connections, and being cautious with static collections that can inadvertently hold objects indefinitely.


2)	What tools or techniques are used in Java to identify and fix memory leaks?
In Java, several tools and techniques are used to identify and fix memory leaks. Profiling tools like
VisualVM, JProfiler, or YourKit provide insights into memory usage and help pinpoint leaking objects. Heap dump analyzers such as Eclipse Memory Analyzer (MAT) are useful for analyzing large amounts of memory data to identify suspicious consumption patterns. Additionally, code review and ensuring proper resource management, such as closing streams and sessions, are crucial techniques for preventing memory leaks.


3)	Describe the Java memory model.
The Java Memory Model (JMM) defines how threads interact through memory and what behaviors are allowed in concurrent execution. It specifies the rules for reading and writing to memory
variables and how changes made by one thread become visible to others. The JMM ensures visibility, atomicity, and ordering of variables to avoid issues like race conditions and data inconsistency. It is fundamental for developing robust and thread-safe Java applications, ensuring that interactions
between threads are predictable and consistent.


4)	What is the visibility problem in the Java Memory Model?
The visibility problem in the Java Memory Model refers to issues where changes to a variable made by one thread are not immediately or consistently visible to other threads. This can occur because each thread may cache variables locally instead of reading and writing directly to and from main memory. Without proper synchronization, there's no guarantee that a thread will see the most
recent write to a variable by another thread, leading to inconsistencies and errors in multithreaded applications.


5)	How does garbage collection handle circular references?
Garbage collection in Java handles circular references by using algorithms that do not rely on
reference counting. Java's garbage collector looks for objects that are not reachable by any thread in the program, regardless of whether they refer to each other. This means even if two or more objects are referencing each other in a circular manner but no live thread can reach them, they are still identified as unreachable and eligible for garbage collection.


6)	How does the static keyword affect memory management in Java?
In Java, the static keyword affects memory management by allocating memory for static fields and methods not with individual instances but at the class level. This means that static elements are

 
stored in the Java method area, a part of the heap memory dedicated to storing class structures and static content. Static elements are created when the class is loaded by the JVM and remain in
memory as long as the class stays loaded, shared among all instances of that class.


7)	What is the difference between NoClassDefFoundError and ClassNotFoundException?
The difference between NoClassDefFoundError and ClassNotFoundException in Java centers on when these errors occur. ClassNotFoundException is thrown when the Java Virtual Machine (JVM) cannot find a class at runtime that was available at compile time, typically because it's not available on the classpath. This is often encountered when using methods like Class.forName(). On the other hand, NoClassDefFoundError occurs when the JVM finds a class at compile time but not during runtime, usually due to issues like a class failing to load because of static initialization failure or changes in classpath after compilation.


8)	How does class loading affect memory usage?
Class loading in Java affects memory usage by increasing it each time a class is loaded into the JVM.
Each class needs memory for its metadata, methods, and associated objects. This loading is
necessary for the JVM to use the class, but if many classes are loaded, or large libraries are in use, memory consumption can increase significantly. Proper management of class loaders can help in optimizing memory usage, especially in large applications.


9)	Is it possible to unload a class in Java?
In Java, directly unloading a class is not possible as Java does not provide explicit control over the unloading of classes. However, a class can be unloaded when its class loader is garbage collected. This happens if there are no active references to the class and its class loader from any part of the program. Essentially, for a class to be eligible for unloading, all instances of the class and the class loader itself must no longer be in use.


10)	How do JVM optimizations affect the performance of Java applications?
JVM optimizations significantly enhance the performance of Java applications by improving execution efficiency. The JVM uses techniques like Just-In-Time (JIT) compilation, which converts Java bytecode into native machine code that runs faster on the processor. It also employs methods like garbage
collection optimization and inlining functions to reduce memory usage and execution time. These optimizations help Java programs run faster and more smoothly, making efficient use of system resources.








 
Exception Handling



1)	What happens when an exception is thrown in a static initialization block?
When an exception is thrown in a static initialization block in Java, it prevents the class from being loaded properly. This results in a java.lang.ExceptionInInitializerError. If an attempt is made to use the class afterwards, the JVM will throw a NoClassDefFoundError because the class initialization
previously failed. This mechanism ensures that no class is used unless it has been correctly and fully initialized.


2)	Provide an example of when you would purposely use a checked exception over an unchecked one.
You would purposely use a checked exception when you want to enforce error handling by the caller of a method. For instance, in situations where a method deals with reading from a file or querying a database, you might use a checked exception like IOException or SQLException. These exceptions
alert the developer that there must be logic to handle these potential issues, ensuring that such problems are acknowledged and addressed at compile time, preventing overlooked errors that could occur at runtime.


3)	Have you ever used a finally block? If yes, can you provide a scenario where you have used it?
In Java, a finally block is crucial for resource management, ensuring resources like streams, connections, or files are properly closed regardless of whether an exception occurs. For example, when working with file handling, even if an IOException occurs, the finally block ensures that the file stream is closed to avoid resource leaks, thus maintaining system stability and performance.
4)	Was there ever a time when the finally block caused any unexpected behavior or side effects?
A finally block in Java generally executes reliably, but unexpected behavior can arise if a new exception is thrown within the finally block itself. For instance, if an exception occurs while closing a resource in the finally block, it can obscure an exception that was thrown in the try block, leading to the loss of the original exception's details. This is why it's essential to handle exceptions within the finally block carefully to prevent such issues.


5)	What is a deadlock in multithreading? How can you prevent it?
A deadlock in multithreading occurs when two or more threads are each waiting for the other to release a resource they need to continue, resulting in all involved threads being blocked indefinitely. To prevent deadlocks, ensure that all threads acquire locks in a consistent order, avoid holding multiple locks if possible, and use timeout options with lock attempts. Another strategy is to use a lock hierarchy or a try-lock method to manage resources dynamically without stalling.




 
6)	What issues might arise when both method overloading and overriding are used in the same class hierarchy?
Using both method overloading and overriding in the same class hierarchy can lead to confusion and errors in Java. Overloading methods within a class allows multiple methods with the same name but different parameters. Overriding changes the behavior of a method in a subclass. When these concepts are combined, it can be unclear whether a method call is invoking an overloaded method or an overridden one, especially if the signatures are similar. This ambiguity can make the code
harder to read and maintain, and increase the likelihood of bugs.


7)	Why might it be bad practice to catch Throwable?
Catching Throwable in Java is generally considered bad practice because Throwable is the superclass of all errors and exceptions. Catching it means catching both Exception and Error classes. Errors, such as OutOfMemoryError or StackOverflowError, are typically serious problems that a normal
application should not attempt to handle because they are often related to system-level issues. Catching Throwable may prevent the propagation of errors that should naturally cause the program to terminate, potentially leading to system instability or corrupting application state.

</p>
							</div>
					
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../microservices/ms-intro.html">Microservices</a>
					</div>
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../java/java8/introduction.html">Java 8 Features</a>
					</div>
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../DP/introduction.html">Design Patterns</a>
					</div>
					<div class="navbar-item is-hoverable">
						<a class="navbar-link" href="../../interview/interview-questions.html">Interview Questions</a>
					</div>
					<label class="theme-toggler div-to-hide">
						<input type="checkbox" id="switch-theme-checkbox">
						<span class="icon"></span>
					</label>
				</div>
			</div>
		</div>
		<label class="theme-toggler div-to-desk" style="top: 22px;">
			<input type="checkbox" id="switch-theme-mobile">
			<span class="icon"></span>
		</label>
	</nav>

	<div class="body">
		<div class="nav-container">
			<aside class="nav">
				<div class="nav-panel-menu is-active" data-panel="menu">
					<li class="nav-item" data-depth="0">
						<ul class="nav-list">
							<h4>Interview Questions</h4>
							<li class="nav-item"><a class="nav-link" href="../java/random.html">Java
								Core</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-interview-questions.html">Java
									Basics</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-abstraction.html">Java
								Abstraction</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-encapsulation.html">Java
									Encapsulation</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-polymorphism.html">Java
									Polymorphism</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-inheritance.html">Java
									Inheritance </a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-string.html">Java
								String</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-overloading-Overriding.html">Java
									Overloading and Overriding</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-exception.html">Java
									Exception Handling</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-multithreading.html">Java
									Multithreading</a></li>
							<h4> Collections Interview Questions</h4>
							<li class="nav-item"><a class="nav-link" href="../java/java-collections.html">Java
									Collections </a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-list.html">Java
									List </a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-set.html">Java
									Set </a></li>
							<li class="nav-item"><a class="nav-link" href="../java/java-map.html">Java
									Map</a></li>
							<li class="nav-item"><a class="nav-link" href="../java/miscellaneous.html">Java
								Advanced</a></li>
							<h4> Java Programming Interview Questions</h4>
							<li class="nav-item"><a class="nav-link" href="../java/programs.html">Java
								Programs </a></li>
						</ul>
					</li>
				</div>
			</aside>
		</div>
		<main class="article">
			<div class="toolbar">
				<button class="navbar-burger" id="nav-toggle-1">
					<span></span>
					<span></span>
				</button>
				<nav class="breadcrumbs">
					<ul>
						<li><a href="../../interview/interview-questions.html">Interview Questions</a></li>
						<li><a href="../java/java-interview-questions.html">Java Basics</a></li>
					</ul>
				</nav>
			</div>
			<div class="doc">
				<nav class="breadcrumbs div-to-hide">
					<ul>
						<li><a href="../../interview/interview-questions.html">Interview Questions</a></li>
						<li><a href="../java/java-interview-questions.html">Java Basics</a></li>
					</ul>

				</nav>
				<article>
					<div class="card-body">
						<h4><b>Java Basic Interview Questions</b></h4>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>1. What do you know about Java?</summary>
							<div class="toggle-content">
								<p>Java is a high-level programming language originally developed by Sun
									Microsystems and released in 1995. Java runs on a variety of platforms, such
									as
									Windows, Mac OS, and the various versions of UNIX.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>2. What are the supported platforms by Java Programming Language?</summary>
							<div class="toggle-content">
								<p>Java runs on a variety of platforms, such as Windows, Mac OS, and the various
									versions of UNIX/Linux like HP-Unix, Sun Solaris, Redhat Linux, Ubuntu,
									CentOS,
									etc.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>3. List any five features of Java?</summary>
							<div class="toggle-content">
								<p>Some features include Object Oriented, Platform Independent, Robust,
									Interpreted,
									Multi-threaded</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>4. Why is Java Architectural Neutral?</summary>
							<div class="toggle-content">
								<p>It’s compiler generates an architecture-neutral object file format, which
									makes
									the compiled code to be executable on many processors, with the presence of
									Java
									runtime system.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>5. How Java enabled High Performance?</summary>
							<div class="toggle-content">
								<p>Java uses Just-In-Time compiler to enable high performance. Just-In-Time
									compiler
									is a program that turns Java bytecode, which is a program that contains
									instructions that must be interpreted into instructions that can be sent
									directly to the processor.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>6. Why Java is considered dynamic?</summary>
							<div class="toggle-content">
								<p>It is designed to adapt to an evolving environment. Java programs can carry
									extensive amount of run-time information that can be used to verify and
									resolve
									accesses to objects on run-time.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>7. What is Java Virtual Machine and how it is considered in context of
								Java’s
								platform independent feature?</summary>
							<div class="toggle-content">
								<p>When Java is compiled, it is not compiled into platform specific machine,
									rather
									into platform independent byte code. This byte code is distributed over the
									web
									and interpreted by virtual Machine (JVM) on whichever platform it is being
									run.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>8. What is a Class Variable?</summary>
							<div class="toggle-content">
								<p>These are variables declared with in a class, outside any method, with the
									static
									keyword.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>9. What do you mean by Object?</summary>
							<div class="toggle-content">
								<p>Object is a runtime entity and it’s state is stored in fields and behavior is
									shown via methods. Methods operate on an object's internal state and serve
									as
									the primary mechanism for object-to-object communication.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>1. Define class?</summary>
							<div class="toggle-content">
								<p>A class is a blue print from which individual objects are created. A class
									can
									contain fields and methods to describe the behavior of an object.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>11. What kind of variables a class can consist of?</summary>
							<div class="toggle-content">
								<p>A class consist of Local variable, instance variables and class variables.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>12. What is a Local Variable?</summary>
							<div class="toggle-content">
								<p>Variables defined inside methods, constructors or blocks are called local
									variables. The variable will be declared and initialized within the method
									and
									it will be destroyed when the method has completed.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>13. What is a Instance Variable?</summary>
							<div class="toggle-content">
								<p>Instance variables are variables within a class but outside any method. These
									variables are instantiated when the class is loaded.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>14. What is Singleton class?</summary>
							<div class="toggle-content">
								<p>Singleton class control object creation, limiting the number to one but
									allowing
									the flexibility to create more objects if the situation changes.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>15. What do you mean by Constructor?</summary>
							<div class="toggle-content">
								<p>Constructor gets invoked when a new object is created. Every class has a
									constructor. If we do not explicitly write a constructor for a class the
									java
									compiler builds a default constructor for that class.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>16. What is a static variable?</summary>
							<div class="toggle-content">
								<p>Class variables also known as static variables are declared with the static
									keyword in a class, but outside a method, constructor or a block.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>17. What do you mean by Access Modifier?</summary>
							<div class="toggle-content">
								<p>Java provides access modifiers to set access levels for classes, variables,
									methods and constructors. A member has package or default accessibility when
									no
									accessibility modifier is specified.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>18. What is protected access modifier?</summary>
							<div class="toggle-content">
								<p>Variables, methods and constructors which are declared protected in a
									superclass
									can be accessed only by the subclasses in other package or any class within
									the
									package of the protected members' class.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>19. Why is String class considered immutable?</summary>
							<div class="toggle-content">
								<p>The String class is immutable, so that once it is created a String object
									cannot
									be changed. Since String is immutable it can safely be shared between many
									threads ,which is considered very important for multithreaded programming.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>20. Why is StringBuffer called mutable?</summary>
							<div class="toggle-content">
								<p>The String class is considered as immutable, so that once it is created a
									String
									object cannot be changed. If there is a necessity to make alot of
									modifications
									to Strings of characters then StringBuffer should be used.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>21. What is the difference between StringBuffer and StringBuilder class?
							</summary>
							<div class="toggle-content">
								<p>Use StringBuilder whenever possible because it is faster than StringBuffer.
									But,
									if thread safety is necessary then use StringBuffer objects.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>22. Explain garbage collection in Java?</summary>
							<div class="toggle-content">
								<p>It uses garbage collection to free the memory. By cleaning those objects that
									is
									no longer reference by any of the program.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>23. Define immutable object?</summary>
							<div class="toggle-content">
								<p>An immutable object can’t be changed once it is created.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>24. Explain the usage of this() with constructors?</summary>
							<div class="toggle-content">
								<p>It is used with variables or methods and used to call constructer of same
									class.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>25. Explain the following line used under Java Program −
								public static void main (String args[ ])
							</summary>
							<div class="toggle-content">
								<p>The following shows the explanation individually −</p>
								<ul class="list">
									<li>
										<p>public − it is the access specifier.</p>
									</li>
									<li>
										<p>static − it allows main() to be called without instantiating a
											particular
											instance of a class.</p>
									</li>
									<li>
										<p>void − it affirns the compiler that no value is returned by main().
										</p>
									</li>
									<li>
										<p>main() − this method is called at the beginning of a Java program.
										</p>
									</li>
									<li>
										<p>String args[ ] − args parameter is an instance array of class String
										</p>
									</li>
								</ul>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>26. Define JRE i.e. Java Runtime Environment?</summary>
							<div class="toggle-content">
								<p>Java Runtime Environment is an implementation of the Java Virtual Machine
									which
									executes Java programs. It provides the minimum requirements for executing a
									Java application;</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>27. What is JAR file?</summary>
							<div class="toggle-content">
								<p>JAR files is Java Archive fles and it aggregates many files into one. It
									holds
									Java classes in a library. JAR files are built on ZIP file format and have
									.jar
									file extension.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>28. What is a WAR file?</summary>
							<div class="toggle-content">
								<p>This is Web Archive File and used to store XML, java classes, and JavaServer
									pages. which is used to distribute a collection of JavaServer Pages, Java
									Servlets, Java classes, XML files, static Web pages etc.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>29. Define JIT compiler?</summary>
							<div class="toggle-content">
								<p>It improves the runtime performance of computer programs based on bytecode.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>30. What is the difference between object oriented programming language and
								object
								based programming language?</summary>
							<div class="toggle-content">
								<p>Object based programming languages follow all the features of OOPs except
									Inheritance. JavaScript is an example of object based programming languages.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>31. What is the purpose of default constructor?</summary>
							<div class="toggle-content">
								<p>The java compiler creates a default constructor only if there is no
									constructor
									in the class.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>32. Can a constructor be made final?</summary>
							<div class="toggle-content">
								<p>No, this is not possible.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary> What 33.is static block?</summary>
							<div class="toggle-content">
								<p>It is used to initialize the static data member, It is excuted before main
									method
									at the time of classloading.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>34. What is final class?</summary>
							<div class="toggle-content">
								<p>Final classes are created so the methods implemented by that class cannot be
									overridden. It can’t be inherited.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>35. What is NullPointerException?</summary>
							<div class="toggle-content">
								<p>A NullPointerException is thrown when calling the instance method of a null
									object, accessing or modifying the field of a null object etc.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>36. How many bits are used to represent Unicode, ASCII, UTF-16, and UTF-8
								characters?</summary>
							<div class="toggle-content">
								<p>Unicode requires 16 bits and ASCII require 7 bits. Although the ASCII
									character
									set uses only 7 bits, it is usually represented as 8 bits. UTF-8 represents
									characters using 8, 16, and 18 bit patterns. UTF-16 uses 16-bit and larger
									bit
									patterns.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>37. What are Wrapper classes?</summary>
							<div class="toggle-content">
								<p>These are classes that allow primitive types to be accessed as objects.
									Example:
									Integer, Character, Double, Boolean etc.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>38. What is the difference between static and non-static variables?
							</summary>
							<div class="toggle-content">
								<p>A static variable is associated with the class as a whole rather than with
									specific instances of a class. Non-static variables take on unique values
									with
									each object instance.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>39. What is Serialization and deserialization?</summary>
							<div class="toggle-content">
								<p>Serialization is the process of writing the state of an object to a byte
									stream.
									Deserialization is the process of restoring these objects.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>40. What's the difference between constructors and other methods?</summary>
							<div class="toggle-content">
								<p>Constructors must have the same name as the class and can not return a value.
									They are only called once while regular methods could be called many times.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>41. What is a transient variable?</summary>
							<div class="toggle-content">
								<p>A transient variable is a variable that may not be serialized during
									Serialization and which is initialized by its default value during
									de-serialization,</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>42. What is synchronization?</summary>
							<div class="toggle-content">
								<p>Synchronization is the capability to control the access of multiple threads
									to
									shared resources. synchronized keyword in java provides locking which
									ensures
									mutual exclusive access of shared resource and prevent data race.</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>43. Does garbage collection guarantee that a program will not run out of
								memory?</summary>
							<div class="toggle-content">
								<p>Garbage collection does not guarantee that a program will not run out of
									memory.
									It is possible for programs to use up memory resources faster than they are
									garbage collected. It is also possible for programs to create objects that
									are
									not subject to garbage collection.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>44. What is the difference between a break statement and a continue
								statement?</summary>
							<div class="toggle-content">
								<p>A break statement results in the termination of the statement to which it
									applies
									(switch, for, do, or while). A continue statement is used to end the current
									loop iteration and return control to the loop statement.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>45. If a variable is declared as private, where may the variable be
								accessed?</summary>
							<div class="toggle-content">
								<p>A private variable may only be accessed within the class in which it is
									declared.
								</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>46. What is the purpose of the System class?</summary>
							<div class="toggle-content">
								<p>The purpose of the System class is to provide access to system resources.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>47. List primitive Java types?</summary>
							<div class="toggle-content">
								<p>The eight primitive types are byte, char, short, int, long, float, double,
									and
									boolean.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>48. Under what conditions is an object's finalize() method invoked by the
								garbage
								collector?</summary>
							<div class="toggle-content">
								<p>The garbage collector invokes an object's finalize() method when it detects
									that
									the object has become unreachable.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>49. What are ClassLoaders?</summary>
							<div class="toggle-content">
								<p>A class loader is an object that is responsible for loading classes. The
									class
									ClassLoader is an abstract class.</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>50. Why do we need wrapper classes?</summary>
							<div class="toggle-content">
								<p>We can pass them around as method parameters where a method expects an
									object. It
									also provides utility methods.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>51. What is the Locale class?</summary>
							<div class="toggle-content">
								<p>The Locale class is used to tailor program output to the conventions of a
									particular geographic, political, or cultural region.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>52. What are synchronized methods and synchronized statements?</summary>
							<div class="toggle-content">
								<p>Synchronized methods are methods that are used to control access to an
									object. A
									synchronized statement can only be executed after a thread has acquired the
									lock
									for the object or class referenced in the synchronized statement.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>53. Describe life cycle of thread?</summary>
							<div class="toggle-content">
								<p>A thread is a execution in a program. The life cycle of a thread include −
								</p>
								<ul class="list">
									<li>Newborn state</li>
									<li>Runnable state</li>
									<li>Running state</li>
									<li>Blocked state</li>
									<li>Dead state</li>
								</ul>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>54. Why Generics are used in Java?</summary>
							<div class="toggle-content">
								<p>Generics provide compile-time type safety that allows programmers to catch
									invalid types at compile time. Java Generic methods and generic classes
									enable
									programmers to specify, with a single method declaration, a set of related
									methods or, with a single class declaration, a set of related types.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>55. What environment variables do I need to set on my machine in order to
								be able
								to
								run Java programs?</summary>
							<div class="toggle-content">
								<p>CLASSPATH and PATH are the two variables.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>56. Is there any need to import java.lang package?</summary>
							<div class="toggle-content">
								<p>No, there is no need to import this package. It is by default loaded
									internally
									by the JVM.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>57. What is Externalizable interface?</summary>
							<div class="toggle-content">
								<p>Externalizable is an interface which contains two methods readExternal and
									writeExternal. These methods give you a control over the serialization
									mechanism.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>58. If System.exit (0); is written at the end of the try block, will the
								finally
								block still execute?</summary>
							<div class="toggle-content">
								<p>No in this case the finally block will not execute because when you say
									System.exit (0); the control immediately goes out of the program, and thus
									finally never executes.</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>59. What is the GregorianCalendar class?</summary>
							<div class="toggle-content">
								<p>The GregorianCalendar provides support for traditional Western calendars</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>60. What is the SimpleTimeZone class?</summary>
							<div class="toggle-content">
								<p>The SimpleTimeZone class provides support for a Gregorian calendar .</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>61. What is difference between Path and Classpath?</summary>
							<div class="toggle-content">
								<p>Path and Classpath are operating system level environment variales. Path is
									defines where the system can find the executables(.exe) files and classpath
									is
									used to specify the location of .class files.</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>62. What is an object's lock and which object's have locks?</summary>
							<div class="toggle-content">
								<p>An object's lock is a mechanism that is used by multiple threads to obtain
									synchronized access to the object. A thread may execute a synchronized
									method of
									an object only after it has acquired the object's lock.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>63. What is Downcasting?</summary>
							<div class="toggle-content">
								<p>It is the casting from a general to a more specific type, i.e. casting down
									the
									hierarchy.</p>
							</div>
						</details><br>

						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>64. What is the difference between inner class and nested class?</summary>
							<div class="toggle-content">
								<p>When a class is defined within a scope of another class, then it becomes
									inner
									class. If the access modifier of the inner class is static, then it becomes
									nested class.</p>
							</div>
						</details><br>
						<details id="details1" onclick="closeOtherDetails('details1')">
							<summary>65. What is constructor chaining and how is it achieved in Java?</summary>
							<div class="toggle-content">
								<p>A child object constructor always first needs to construct its parent. In
									Java it
									is done via an implicit call to the no-args constructor as the first
									statement.
								</p>
							</div>
						</details><br>
					</div>
				</article>
			</div>
			<div class="card-footer">
				<ul class="pagination justify-content-center mb-4">
					<li class="page-item"><a class="page-link btn-outline-primary" href="../java/random.html">⇐
						Previous</a></li>
					<li class="page-item"><a class="page-link" href="../java/java-abstraction.html">Next
							⇒</a></li>
				</ul>
			</div>
			<button onclick="topFunction()" id="myBtn" title="Go to top"><img height="30" width="30" src="../../scripts/images/top.jpeg"></button>
		</main>
	</div>
	<script>
		window.addEventListener('DOMContentLoaded', () => {
			window.scrollTo(0, 0);
		})
	</script>
	<script>
		// Get the button
		let mybutton = document.getElementById("myBtn");

		// When the user scrolls down 20px from the top of the document, show the button
		window.onscroll = function () {scrollFunction()};

		function scrollFunction() {
			if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
				mybutton.style.display = "block";
			} else {
				mybutton.style.display = "none";
			}
		}
		// When the user clicks on the button, scroll to the top of the document
		function topFunction() {
			document.body.scrollTop = 0;
			document.documentElement.scrollTop = 0;
		}
	</script>

<footer class="footer">
	<p>©
		<script>var d = new Date();
			document.write(d.getFullYear());</script> The content is copyrighted to Shoz
		Sheikh.
	</p>
</footer>

</body></html>
